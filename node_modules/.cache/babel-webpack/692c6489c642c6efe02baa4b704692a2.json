{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { linearFindNearest } from './array.js';\nimport { clamp } from './math.js';\n\n/**\n * @typedef {function((number|undefined), number, number): (number|undefined)} Type\n */\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, delta, direction) {\n      if (resolution !== undefined) {\n        var z = linearFindNearest(resolutions, resolution, direction);\n        z = clamp(z + delta, 0, resolutions.length - 1);\n        var index = Math.floor(z);\n        if (z != index && index < resolutions.length - 1) {\n          var power = resolutions[index] / resolutions[index + 1];\n          return resolutions[index] / Math.pow(power, z - index);\n        } else {\n          return resolutions[index];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_maxLevel Maximum level.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_maxLevel) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, delta, direction) {\n      if (resolution !== undefined) {\n        var offset = -direction / 2 + 0.5;\n        var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);\n        var newLevel = Math.max(oldLevel + delta, 0);\n        if (opt_maxLevel !== undefined) {\n          newLevel = Math.min(newLevel, opt_maxLevel);\n        }\n        return maxResolution / Math.pow(power, newLevel);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"sources":["../../src/ol/resolutionconstraint.js"],"names":["let","const"],"mappings":"AAAA;;;AAGA,SAAQ,iBAAiB,QAAO,YAAY;AAC5C,SAAQ,KAAK,QAAO,WAAW;;;;;;;;;;AAY/B,OAAO,SAAS,uBAAuB,CAAC,WAAW,EAAE;EACnD;;;;;;;IAOE,UAAS,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE;MACrC,IAAI,UAAU,KAAK,SAAS,EAAE;QAC5BA,IAAI,CAAC,GAAG,iBAAiB,CAAC,WAAW,EAAE,UAAU,EAAE,SAAS,CAAC;QAC7D,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;QAC/CC,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3B,IAAI,CAAC,IAAI,KAAK,IAAI,KAAK,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;UAChDA,IAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC,KAAK,GAAG,CAAC,CAAC;UACzD,OAAO,WAAW,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC;SACvD,MAAM;UACL,OAAO,WAAW,CAAC,KAAK,CAAC;QAC1B;OACF,MAAM;QACL,OAAO,SAAS;MACjB;;EACF;AAEJ;;;;;;;;AASD,OAAO,SAAS,iBAAiB,CAAC,KAAK,EAAE,aAAa,EAAE,YAAY,EAAE;EACpE;;;;;;;IAOE,UAAS,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE;MACrC,IAAI,UAAU,KAAK,SAAS,EAAE;QAC5BA,IAAM,MAAM,GAAG,CAAC,SAAS,GAAG,CAAC,GAAG,GAAG;QACnCA,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CACzB,IAAI,CAAC,GAAG,CAAC,aAAa,GAAG,UAAU,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC;QAClED,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,KAAK,EAAE,CAAC,CAAC;QAC5C,IAAI,YAAY,KAAK,SAAS,EAAE;UAC9B,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,YAAY,CAAC;QAC5C;QACD,OAAO,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC;OACjD,MAAM;QACL,OAAO,SAAS;MACjB;;EACF;AACJ","sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport {linearFindNearest} from './array.js';\nimport {clamp} from './math.js';\n\n\n/**\n * @typedef {function((number|undefined), number, number): (number|undefined)} Type\n */\n\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function(resolution, delta, direction) {\n      if (resolution !== undefined) {\n        let z = linearFindNearest(resolutions, resolution, direction);\n        z = clamp(z + delta, 0, resolutions.length - 1);\n        const index = Math.floor(z);\n        if (z != index && index < resolutions.length - 1) {\n          const power = resolutions[index] / resolutions[index + 1];\n          return resolutions[index] / Math.pow(power, z - index);\n        } else {\n          return resolutions[index];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_maxLevel Maximum level.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_maxLevel) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function(resolution, delta, direction) {\n      if (resolution !== undefined) {\n        const offset = -direction / 2 + 0.5;\n        const oldLevel = Math.floor(\n          Math.log(maxResolution / resolution) / Math.log(power) + offset);\n        let newLevel = Math.max(oldLevel + delta, 0);\n        if (opt_maxLevel !== undefined) {\n          newLevel = Math.min(newLevel, opt_maxLevel);\n        }\n        return maxResolution / Math.pow(power, newLevel);\n      } else {\n        return undefined;\n      }\n    });\n}\n"]},"metadata":{},"sourceType":"module"}