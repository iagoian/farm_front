{"ast":null,"code":"import _classCallCheck from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport var ReplaySubject = /*#__PURE__*/function (_Subject) {\n  _inherits(ReplaySubject, _Subject);\n  var _super = _createSuper(ReplaySubject);\n  function ReplaySubject() {\n    var _this;\n    var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n    var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    var scheduler = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, ReplaySubject);\n    _this = _super.call(this);\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n    return _this;\n  }\n  _createClass(ReplaySubject, [{\n    key: \"nextInfiniteTimeWindow\",\n    value: function nextInfiniteTimeWindow(value) {\n      if (!this.isStopped) {\n        var _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n          _events.shift();\n        }\n      }\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"nextTimeWindow\",\n    value: function nextTimeWindow(value) {\n      if (!this.isStopped) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n      }\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      var _infiniteTimeWindow = this._infiniteTimeWindow;\n      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n      var scheduler = this.scheduler;\n      var len = _events.length;\n      var subscription;\n      if (this.closed) {\n        throw new ObjectUnsubscribedError();\n      } else if (this.isStopped || this.hasError) {\n        subscription = Subscription.EMPTY;\n      } else {\n        this.observers.push(subscriber);\n        subscription = new SubjectSubscription(this, subscriber);\n      }\n      if (scheduler) {\n        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n      }\n      if (_infiniteTimeWindow) {\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n          subscriber.next(_events[i]);\n        }\n      } else {\n        for (var _i = 0; _i < len && !subscriber.closed; _i++) {\n          subscriber.next(_events[_i].value);\n        }\n      }\n      if (this.hasError) {\n        subscriber.error(this.thrownError);\n      } else if (this.isStopped) {\n        subscriber.complete();\n      }\n      return subscription;\n    }\n  }, {\n    key: \"_getNow\",\n    value: function _getNow() {\n      return (this.scheduler || queue).now();\n    }\n  }, {\n    key: \"_trimBufferThenGetEvents\",\n    value: function _trimBufferThenGetEvents() {\n      var now = this._getNow();\n      var _bufferSize = this._bufferSize;\n      var _windowTime = this._windowTime;\n      var _events = this._events;\n      var eventsCount = _events.length;\n      var spliceCount = 0;\n      while (spliceCount < eventsCount) {\n        if (now - _events[spliceCount].time < _windowTime) {\n          break;\n        }\n        spliceCount++;\n      }\n      if (eventsCount > _bufferSize) {\n        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n      }\n      if (spliceCount > 0) {\n        _events.splice(0, spliceCount);\n      }\n      return _events;\n    }\n  }]);\n  return ReplaySubject;\n}(Subject);\nvar ReplayEvent = /*#__PURE__*/_createClass(function ReplayEvent(time, value) {\n  _classCallCheck(this, ReplayEvent);\n  this.time = time;\n  this.value = value;\n});","map":{"version":3,"sources":["../../src/internal/ReplaySubject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        if (!this.isStopped) {\n            const _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map"]},"metadata":{},"sourceType":"module"}