{"ast":null,"code":"/**\n * @module ol/color\n */\nimport { assert } from './asserts.js';\nimport { clamp } from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nvar HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nvar NAMED_COLOR_RE_ = /^([a-z]*)$/i;\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  } else {\n    return toString(color);\n  }\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  var el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    var rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  } else {\n    return '';\n  }\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport var fromString = function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  var MAX_CACHE_SIZE = 1024;\n\n  /**\n   * @type {Object<string, Color>}\n   */\n  var cache = {};\n\n  /**\n   * @type {number}\n   */\n  var cacheSize = 0;\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      var color;\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          var i = 0;\n          for (var key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n      return color;\n    }\n  );\n}();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  } else {\n    return fromString(color);\n  }\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  var r, g, b, a, color;\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    var n = s.length - 1; // number of hex digits\n    var d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    var hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.indexOf('rgba(') == 0) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.indexOf('rgb(') == 0) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    assert(false, 14); // Invalid color\n  }\n\n  return color;\n}\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);\n  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);\n  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  var r = color[0];\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n  var g = color[1];\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n  var b = color[2];\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n  var a = color[3] === undefined ? 1 : color[3];\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}","map":{"version":3,"sources":["../../src/ol/color.js"],"names":["const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/color\n */\nimport {assert} from './asserts.js';\nimport {clamp} from './math.js';\n\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nconst NAMED_COLOR_RE_ = /^([a-z]*)$/i;\n\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  } else {\n    return toString(color);\n  }\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  const el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    const rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  } else {\n    return '';\n  }\n}\n\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport const fromString = (\n  function() {\n\n    // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n    // semantics, whenever the cache grows too large we simply delete an\n    // arbitrary 25% of the entries.\n\n    /**\n     * @const\n     * @type {number}\n     */\n    const MAX_CACHE_SIZE = 1024;\n\n    /**\n     * @type {Object<string, Color>}\n     */\n    const cache = {};\n\n    /**\n     * @type {number}\n     */\n    let cacheSize = 0;\n\n    return (\n      /**\n       * @param {string} s String.\n       * @return {Color} Color.\n       */\n      function(s) {\n        let color;\n        if (cache.hasOwnProperty(s)) {\n          color = cache[s];\n        } else {\n          if (cacheSize >= MAX_CACHE_SIZE) {\n            let i = 0;\n            for (const key in cache) {\n              if ((i++ & 3) === 0) {\n                delete cache[key];\n                --cacheSize;\n              }\n            }\n          }\n          color = fromStringInternal_(s);\n          cache[s] = color;\n          ++cacheSize;\n        }\n        return color;\n      }\n    );\n\n  })();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  } else {\n    return fromString(color);\n  }\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  let r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) { // hex\n    const n = s.length - 1; // number of hex digits\n    let d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    const hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.indexOf('rgba(') == 0) { // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.indexOf('rgb(') == 0) { // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    assert(false, 14); // Invalid color\n  }\n  return color;\n}\n\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : color[3];\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n"]},"metadata":{},"sourceType":"module"}