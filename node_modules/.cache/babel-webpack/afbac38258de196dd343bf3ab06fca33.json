{"ast":null,"code":"/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\n\n/**\n * @module ol/sphere\n */\nimport { toRadians, toDegrees } from './math.js';\nimport GeometryType from './geom/GeometryType.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the\n * earth is used (Clarke 1866 Authalic Sphere).\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport var DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = toRadians(c1[1]);\n  var lat2 = toRadians(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  var length = 0;\n  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  var type = geometry.getType();\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  var length = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n      {\n        break;\n      }\n    case GeometryType.LINE_STRING:\n    case GeometryType.LINEAR_RING:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        length = getLengthInternal(coordinates, radius);\n        break;\n      }\n    case GeometryType.MULTI_LINE_STRING:\n    case GeometryType.POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          length += getLengthInternal(coordinates[i], radius);\n        }\n        break;\n      }\n    case GeometryType.MULTI_POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          for (j = 0, jj = coords.length; j < jj; ++j) {\n            length += getLengthInternal(coords[j], radius);\n          }\n        }\n        break;\n      }\n    case GeometryType.GEOMETRY_COLLECTION:\n      {\n        var geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */geometry.getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          length += getLength(geometries[i], opt_options);\n        }\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  var area = 0;\n  var len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0];\n    var y2 = coordinates[i][1];\n    area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  var type = geometry.getType();\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  var area = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n    case GeometryType.LINE_STRING:\n    case GeometryType.MULTI_LINE_STRING:\n    case GeometryType.LINEAR_RING:\n      {\n        break;\n      }\n    case GeometryType.POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/Polygon.js\").default} */geometry.getCoordinates();\n        area = Math.abs(getAreaInternal(coordinates[0], radius));\n        for (i = 1, ii = coordinates.length; i < ii; ++i) {\n          area -= Math.abs(getAreaInternal(coordinates[i], radius));\n        }\n        break;\n      }\n    case GeometryType.MULTI_POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          area += Math.abs(getAreaInternal(coords[0], radius));\n          for (j = 1, jj = coords.length; j < jj; ++j) {\n            area -= Math.abs(getAreaInternal(coords[j], radius));\n          }\n        }\n        break;\n      }\n    case GeometryType.GEOMETRY_COLLECTION:\n      {\n        var geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */geometry.getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          area += getArea(geometries[i], opt_options);\n        }\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = toRadians(c1[1]);\n  var lon1 = toRadians(c1[0]);\n  var dByR = distance / radius;\n  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [toDegrees(lon), toDegrees(lat)];\n}","map":{"version":3,"sources":["../../src/ol/sphere.js"],"names":["const","let"],"mappings":"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","sourcesContent":["/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\n\n/**\n * @module ol/sphere\n */\nimport {toRadians, toDegrees} from './math.js';\nimport GeometryType from './geom/GeometryType.js';\n\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the\n * earth is used (Clarke 1866 Authalic Sphere).\n */\n\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, opt_radius) {\n  const radius = opt_radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *\n      Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, opt_options) {\n  const options = opt_options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT: {\n      break;\n    }\n    case GeometryType.LINE_STRING:\n    case GeometryType.LINEAR_RING: {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n      length = getLengthInternal(coordinates, radius);\n      break;\n    }\n    case GeometryType.MULTI_LINE_STRING:\n    case GeometryType.POLYGON: {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += getLengthInternal(coordinates[i], radius);\n      }\n      break;\n    }\n    case GeometryType.MULTI_POLYGON: {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += getLengthInternal(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case GeometryType.GEOMETRY_COLLECTION: {\n      const geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += getLength(geometries[i], opt_options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n}\n\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area += toRadians(x2 - x1) *\n        (2 + Math.sin(toRadians(y1)) +\n        Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n}\n\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, opt_options) {\n  const options = opt_options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n    case GeometryType.LINE_STRING:\n    case GeometryType.MULTI_LINE_STRING:\n    case GeometryType.LINEAR_RING: {\n      break;\n    }\n    case GeometryType.POLYGON: {\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (geometry).getCoordinates();\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\n      }\n      break;\n    }\n    case GeometryType.MULTI_POLYGON: {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(getAreaInternal(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(getAreaInternal(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case GeometryType.GEOMETRY_COLLECTION: {\n      const geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += getArea(geometries[i], opt_options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n}\n\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, opt_radius) {\n  const radius = opt_radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  const lon = lon1 + Math.atan2(\n    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [toDegrees(lon), toDegrees(lat)];\n}\n"]},"metadata":{},"sourceType":"module"}