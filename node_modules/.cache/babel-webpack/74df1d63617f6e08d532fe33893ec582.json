{"ast":null,"code":"/**\n * @module ol/render/canvas/TextReplay\n */\nimport { getUid } from '../../util.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { intersects } from '../../extent.js';\nimport { matchingChunk } from '../../geom/flat/straightchunk.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport { CANVAS_LINE_DASH } from '../../has.js';\nimport { labelCache, measureTextWidth, defaultTextAlign, measureTextHeight, defaultPadding, defaultLineCap, defaultLineDashOffset, defaultLineDash, defaultLineJoin, defaultFillStyle, checkFont, defaultFont, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextBaseline } from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\nimport CanvasReplay from './Replay.js';\nimport { TEXT_ALIGN } from '../replay.js';\nimport TextPlacement from '../../style/TextPlacement.js';\nvar CanvasTextReplay = /*@__PURE__*/function (CanvasReplay) {\n  function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     */\n    this.declutterGroup_;\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = {};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    this.textState_ = /** @type {import(\"../canvas.js\").TextState} */{};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n    labelCache.prune();\n  }\n  if (CanvasReplay) CanvasTextReplay.__proto__ = CanvasReplay;\n  CanvasTextReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasTextReplay.prototype.constructor = CanvasTextReplay;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTextReplay.prototype.drawText = function drawText(geometry, feature) {\n    var fillState = this.textFillState_;\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    if (this.text_ === '' || !textState || !fillState && !strokeState) {\n      return;\n    }\n    var begin = this.coordinates.length;\n    var geometryType = geometry.getType();\n    var flatCoordinates = null;\n    var end = 2;\n    var stride = 2;\n    var i, ii;\n    if (textState.placement === TextPlacement.LINE) {\n      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      var ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      stride = geometry.getStride();\n      if (geometryType == GeometryType.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == GeometryType.POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == GeometryType.MULTI_POLYGON) {\n        var endss = geometry.getEndss();\n        ends = [];\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      var textAlign = textState.textAlign;\n      var flatOffset = 0;\n      var flatEnd;\n      for (var o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end, this.declutterGroup_);\n        begin = end;\n      }\n      this.endGeometry(geometry, feature);\n    } else {\n      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n      var width = label.width / this.pixelRatio;\n      switch (geometryType) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/LineString.js\").default} */geometry.getFlatMidpoint();\n          break;\n        case GeometryType.CIRCLE:\n          flatCoordinates = /** @type {import(\"../../geom/Circle.js\").default} */geometry.getCenter();\n          break;\n        case GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/MultiLineString.js\").default} */geometry.getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.POLYGON:\n          flatCoordinates = /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getFlatInteriorPoint();\n          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n            return;\n          }\n          stride = 3;\n          break;\n        case GeometryType.MULTI_POLYGON:\n          var interiorPoints = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n            }\n          }\n          end = flatCoordinates.length;\n          if (end == 0) {\n            return;\n          }\n          break;\n        default:\n      }\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill, geometry);\n          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      this.drawTextImage_(label, begin, end);\n      this.endGeometry(geometry, feature);\n    }\n  };\n\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {HTMLCanvasElement} Image.\n   */\n  CanvasTextReplay.prototype.getImage = function getImage(text, textKey, fillKey, strokeKey) {\n    var label;\n    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n    if (!labelCache.containsKey(key)) {\n      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n      var textState = this.textStates[textKey] || this.textState_;\n      var pixelRatio = this.pixelRatio;\n      var scale = textState.scale * pixelRatio;\n      var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var widths = [];\n      var width = measureTextWidths(textState.font, lines, widths);\n      var lineHeight = measureTextHeight(textState.font);\n      var height = lineHeight * numLines;\n      var renderWidth = width + strokeWidth;\n      var context = createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));\n      label = context.canvas;\n      labelCache.set(key, label);\n      if (scale != 1) {\n        context.scale(scale, scale);\n      }\n      context.font = textState.font;\n      if (strokeKey) {\n        context.strokeStyle = strokeState.strokeStyle;\n        context.lineWidth = strokeWidth;\n        context.lineCap = /** @type {CanvasLineCap} */strokeState.lineCap;\n        context.lineJoin = /** @type {CanvasLineJoin} */strokeState.lineJoin;\n        context.miterLimit = strokeState.miterLimit;\n        if (CANVAS_LINE_DASH && strokeState.lineDash.length) {\n          context.setLineDash(strokeState.lineDash);\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n      if (fillKey) {\n        context.fillStyle = fillState.fillStyle;\n      }\n      context.textBaseline = 'middle';\n      context.textAlign = 'center';\n      var leftRight = 0.5 - align;\n      var x = align * label.width / scale + leftRight * strokeWidth;\n      var i;\n      if (strokeKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n      if (fillKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n    }\n    return labelCache.get(key);\n  };\n\n  /**\n   * @private\n   * @param {HTMLCanvasElement} label Label.\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_(label, begin, end) {\n    var textState = this.textState_;\n    var strokeState = this.textStrokeState_;\n    var pixelRatio = this.pixelRatio;\n    var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    var baseline = TEXT_ALIGN[textState.textBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, label.width, textState.padding == defaultPadding ? defaultPadding : textState.padding.map(function (p) {\n      return p * pixelRatio;\n    }), !!textState.backgroundFill, !!textState.backgroundStroke]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);\n  };\n\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   */\n  CanvasTextReplay.prototype.drawChars_ = function drawChars_(begin, end, declutterGroup) {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var fillState = this.textFillState_;\n    var strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = /** @type {import(\"../canvas.js\").StrokeState} */{\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n    var textKey = this.textKey_;\n    if (!(this.textKey_ in this.textStates)) {\n      this.textStates[this.textKey_] = /** @type {import(\"../canvas.js\").TextState} */{\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        scale: textState.scale\n      };\n    }\n    var fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = /** @type {import(\"../canvas.js\").FillState} */{\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n    var pixelRatio = this.pixelRatio;\n    var baseline = TEXT_ALIGN[textState.textBaseline];\n    var offsetY = this.textOffsetY_ * pixelRatio;\n    var text = this.text_;\n    var font = textState.font;\n    var textScale = textState.scale;\n    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n    var widths = this.widths_[font];\n    if (!widths) {\n      this.widths_[font] = widths = {};\n    }\n    this.instructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n      var width = widths[text];\n      if (!width) {\n        width = widths[text] = measureTextWidth(font, text);\n      }\n      return width * textScale * pixelRatio;\n    }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n      var width = widths[text];\n      if (!width) {\n        width = widths[text] = measureTextWidth(font, text);\n      }\n      return width * textScale;\n    }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTextReplay.prototype.setTextStyle = function setTextStyle(textStyle, declutterGroup) {\n    var textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      this.declutterGroup_ = /** @type {import(\"../canvas.js\").DeclutterGroup} */declutterGroup;\n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = this.textFillState_ = null;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = this.textFillState_ = /** @type {import(\"../canvas.js\").FillState} */{};\n        }\n        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n      }\n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = this.textStrokeState_ = null;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = this.textStrokeState_ = /** @type {import(\"../canvas.js\").StrokeState} */{};\n        }\n        var lineDash = textStrokeStyle.getLineDash();\n        var lineDashOffset = textStrokeStyle.getLineDashOffset();\n        var lineWidth = textStrokeStyle.getWidth();\n        var miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n      textState = this.textState_;\n      var font = textStyle.getFont() || defaultFont;\n      checkFont(font);\n      var textScale = textStyle.getScale();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? 1 : textScale;\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\n      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';\n    }\n  };\n  return CanvasTextReplay;\n}(CanvasReplay);\n\n/**\n * @param {string} font Font to use for measuring.\n * @param {Array<string>} lines Lines to measure.\n * @param {Array<number>} widths Array will be populated with the widths of\n * each line.\n * @return {number} Width of the whole text.\n */\nexport function measureTextWidths(font, lines, widths) {\n  var numLines = lines.length;\n  var width = 0;\n  for (var i = 0; i < numLines; ++i) {\n    var currentWidth = measureTextWidth(font, lines[i]);\n    width = Math.max(width, currentWidth);\n    widths.push(currentWidth);\n  }\n  return width;\n}\nexport default CanvasTextReplay;","map":{"version":3,"sources":["../../../../src/ol/render/canvas/TextReplay.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/render/canvas/TextReplay\n */\nimport {getUid} from '../../util.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {intersects} from '../../extent.js';\nimport {matchingChunk} from '../../geom/flat/straightchunk.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport {CANVAS_LINE_DASH} from '../../has.js';\nimport {labelCache, measureTextWidth, defaultTextAlign, measureTextHeight, defaultPadding, defaultLineCap, defaultLineDashOffset, defaultLineDash, defaultLineJoin, defaultFillStyle, checkFont, defaultFont, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextBaseline} from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\nimport CanvasReplay from './Replay.js';\nimport {TEXT_ALIGN} from '../replay.js';\nimport TextPlacement from '../../style/TextPlacement.js';\n\nclass CanvasTextReplay extends CanvasReplay {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    super(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     */\n    this.declutterGroup_;\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = {};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    this.textState_ = /** @type {import(\"../canvas.js\").TextState} */ ({});\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n\n    labelCache.prune();\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawText(geometry, feature) {\n    const fillState = this.textFillState_;\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {\n      return;\n    }\n\n    let begin = this.coordinates.length;\n\n    const geometryType = geometry.getType();\n    let flatCoordinates = null;\n    let end = 2;\n    let stride = 2;\n    let i, ii;\n\n    if (textState.placement === TextPlacement.LINE) {\n      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      let ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      stride = geometry.getStride();\n      if (geometryType == GeometryType.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == GeometryType.POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == GeometryType.MULTI_POLYGON) {\n        const endss = geometry.getEndss();\n        ends = [];\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      const textAlign = textState.textAlign;\n      let flatOffset = 0;\n      let flatEnd;\n      for (let o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          const range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end, this.declutterGroup_);\n        begin = end;\n      }\n      this.endGeometry(geometry, feature);\n\n    } else {\n      const label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n      const width = label.width / this.pixelRatio;\n      switch (geometryType) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/LineString.js\").default} */ (geometry).getFlatMidpoint();\n          break;\n        case GeometryType.CIRCLE:\n          flatCoordinates = /** @type {import(\"../../geom/Circle.js\").default} */ (geometry).getCenter();\n          break;\n        case GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/MultiLineString.js\").default} */ (geometry).getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.POLYGON:\n          flatCoordinates = /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getFlatInteriorPoint();\n          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n            return;\n          }\n          stride = 3;\n          break;\n        case GeometryType.MULTI_POLYGON:\n          const interiorPoints = /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n            }\n          }\n          end = flatCoordinates.length;\n          if (end == 0) {\n            return;\n          }\n          break;\n        default:\n      }\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill, geometry);\n          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      this.drawTextImage_(label, begin, end);\n      this.endGeometry(geometry, feature);\n    }\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {HTMLCanvasElement} Image.\n   */\n  getImage(text, textKey, fillKey, strokeKey) {\n    let label;\n    const key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n\n    if (!labelCache.containsKey(key)) {\n      const strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n      const fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n      const textState = this.textStates[textKey] || this.textState_;\n      const pixelRatio = this.pixelRatio;\n      const scale = textState.scale * pixelRatio;\n      const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n      const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n      const lines = text.split('\\n');\n      const numLines = lines.length;\n      const widths = [];\n      const width = measureTextWidths(textState.font, lines, widths);\n      const lineHeight = measureTextHeight(textState.font);\n      const height = lineHeight * numLines;\n      const renderWidth = (width + strokeWidth);\n      const context = createCanvasContext2D(\n        Math.ceil(renderWidth * scale),\n        Math.ceil((height + strokeWidth) * scale));\n      label = context.canvas;\n      labelCache.set(key, label);\n      if (scale != 1) {\n        context.scale(scale, scale);\n      }\n      context.font = textState.font;\n      if (strokeKey) {\n        context.strokeStyle = strokeState.strokeStyle;\n        context.lineWidth = strokeWidth;\n        context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);\n        context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);\n        context.miterLimit = strokeState.miterLimit;\n        if (CANVAS_LINE_DASH && strokeState.lineDash.length) {\n          context.setLineDash(strokeState.lineDash);\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n      if (fillKey) {\n        context.fillStyle = fillState.fillStyle;\n      }\n      context.textBaseline = 'middle';\n      context.textAlign = 'center';\n      const leftRight = (0.5 - align);\n      const x = align * label.width / scale + leftRight * strokeWidth;\n      let i;\n      if (strokeKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n      if (fillKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n    }\n    return labelCache.get(key);\n  }\n\n  /**\n   * @private\n   * @param {HTMLCanvasElement} label Label.\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  drawTextImage_(label, begin, end) {\n    const textState = this.textState_;\n    const strokeState = this.textStrokeState_;\n    const pixelRatio = this.pixelRatio;\n    const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    const anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end,\n      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\n      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\n      1, label.width,\n      textState.padding == defaultPadding ?\n        defaultPadding : textState.padding.map(function(p) {\n          return p * pixelRatio;\n        }),\n      !!textState.backgroundFill, !!textState.backgroundStroke\n    ]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end,\n      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\n      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\n      1 / pixelRatio, label.width, textState.padding,\n      !!textState.backgroundFill, !!textState.backgroundStroke\n    ]);\n  }\n\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   */\n  drawChars_(begin, end, declutterGroup) {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const fillState = this.textFillState_;\n\n    const strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = /** @type {import(\"../canvas.js\").StrokeState} */ ({\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        });\n      }\n    }\n    const textKey = this.textKey_;\n    if (!(this.textKey_ in this.textStates)) {\n      this.textStates[this.textKey_] = /** @type {import(\"../canvas.js\").TextState} */ ({\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        scale: textState.scale\n      });\n    }\n    const fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = /** @type {import(\"../canvas.js\").FillState} */ ({\n          fillStyle: fillState.fillStyle\n        });\n      }\n    }\n\n    const pixelRatio = this.pixelRatio;\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n\n    const offsetY = this.textOffsetY_ * pixelRatio;\n    const text = this.text_;\n    const font = textState.font;\n    const textScale = textState.scale;\n    const strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n    let widths = this.widths_[font];\n    if (!widths) {\n      this.widths_[font] = widths = {};\n    }\n    this.instructions.push([CanvasInstruction.DRAW_CHARS,\n      begin, end, baseline, declutterGroup,\n      textState.overflow, fillKey, textState.maxAngle,\n      function(text) {\n        let width = widths[text];\n        if (!width) {\n          width = widths[text] = measureTextWidth(font, text);\n        }\n        return width * textScale * pixelRatio;\n      },\n      offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1\n    ]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS,\n      begin, end, baseline, declutterGroup,\n      textState.overflow, fillKey, textState.maxAngle,\n      function(text) {\n        let width = widths[text];\n        if (!width) {\n          width = widths[text] = measureTextWidth(font, text);\n        }\n        return width * textScale;\n      },\n      offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio\n    ]);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setTextStyle(textStyle, declutterGroup) {\n    let textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      this.declutterGroup_ = /** @type {import(\"../canvas.js\").DeclutterGroup} */ (declutterGroup);\n\n      const textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = this.textFillState_ = null;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = this.textFillState_ = /** @type {import(\"../canvas.js\").FillState} */ ({});\n        }\n        fillState.fillStyle = asColorLike(\n          textFillStyle.getColor() || defaultFillStyle);\n      }\n\n      const textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = this.textStrokeState_ = null;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = this.textStrokeState_ = /** @type {import(\"../canvas.js\").StrokeState} */ ({});\n        }\n        const lineDash = textStrokeStyle.getLineDash();\n        const lineDashOffset = textStrokeStyle.getLineDashOffset();\n        const lineWidth = textStrokeStyle.getWidth();\n        const miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset =\n            lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth =\n            lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit =\n            miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(\n          textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n\n      textState = this.textState_;\n      const font = textStyle.getFont() || defaultFont;\n      checkFont(font);\n      const textScale = textStyle.getScale();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? 1 : textScale;\n\n      const textOffsetX = textStyle.getOffsetX();\n      const textOffsetY = textStyle.getOffsetY();\n      const textRotateWithView = textStyle.getRotateWithView();\n      const textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n\n      this.strokeKey_ = strokeState ?\n        (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) +\n        strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +\n        strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :\n        '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\n      this.fillKey_ = fillState ?\n        (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + getUid(fillState.fillStyle))) :\n        '';\n    }\n  }\n}\n\n\n/**\n * @param {string} font Font to use for measuring.\n * @param {Array<string>} lines Lines to measure.\n * @param {Array<number>} widths Array will be populated with the widths of\n * each line.\n * @return {number} Width of the whole text.\n */\nexport function measureTextWidths(font, lines, widths) {\n  const numLines = lines.length;\n  let width = 0;\n  for (let i = 0; i < numLines; ++i) {\n    const currentWidth = measureTextWidth(font, lines[i]);\n    width = Math.max(width, currentWidth);\n    widths.push(currentWidth);\n  }\n  return width;\n}\n\n\nexport default CanvasTextReplay;\n"]},"metadata":{},"sourceType":"module"}