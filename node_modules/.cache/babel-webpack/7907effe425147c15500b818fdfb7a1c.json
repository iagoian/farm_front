{"ast":null,"code":"/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport { abstract } from '../../util.js';\nimport { scale as scaleCoordinate } from '../../coordinate.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { create as createTransform, apply as applyTransform } from '../../transform.js';\n\n/**\n * @abstract\n */\nvar IntermediateCanvasRenderer = /*@__PURE__*/function (CanvasLayerRenderer) {\n  function IntermediateCanvasRenderer(layer) {\n    CanvasLayerRenderer.call(this, layer);\n\n    /**\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToCanvasPixelTransform = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n  }\n  if (CanvasLayerRenderer) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;\n  IntermediateCanvasRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;\n\n  /**\n   * @inheritDoc\n   */\n  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    this.preCompose(context, frameState);\n    var image = this.getImage();\n    if (image) {\n      // clipped rendering if layer extent is set\n      var extent = layerState.extent;\n      var clipped = extent !== undefined && !containsExtent(extent, frameState.extent) && intersects(extent, frameState.extent);\n      if (clipped) {\n        this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */extent);\n      }\n      var imageTransform = this.getImageTransform();\n      // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n      var alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity;\n\n      // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n      var dx = imageTransform[4];\n      var dy = imageTransform[5];\n      var dw = image.width * imageTransform[0];\n      var dh = image.height * imageTransform[3];\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n      context.globalAlpha = alpha;\n      if (clipped) {\n        context.restore();\n      }\n    }\n    this.postCompose(context, frameState, layerState);\n  };\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n  IntermediateCanvasRenderer.prototype.getImage = function getImage() {\n    return abstract();\n  };\n\n  /**\n   * @abstract\n   * @return {!import(\"../../transform.js\").Transform} Image transform.\n   */\n  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform() {\n    return abstract();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n    var pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  };\n  return IntermediateCanvasRenderer;\n}(CanvasLayerRenderer);\nexport default IntermediateCanvasRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/IntermediateCanvas.js"],"names":["super","const"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport {abstract} from '../../util.js';\nimport {scale as scaleCoordinate} from '../../coordinate.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, intersects} from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport {create as createTransform, apply as applyTransform} from '../../transform.js';\n\n/**\n * @abstract\n */\nclass IntermediateCanvasRenderer extends CanvasLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   */\n  constructor(layer) {\n\n    super(layer);\n\n    /**\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToCanvasPixelTransform = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  composeFrame(frameState, layerState, context) {\n\n    this.preCompose(context, frameState);\n\n    const image = this.getImage();\n    if (image) {\n\n      // clipped rendering if layer extent is set\n      const extent = layerState.extent;\n      const clipped = extent !== undefined &&\n          !containsExtent(extent, frameState.extent) &&\n          intersects(extent, frameState.extent);\n      if (clipped) {\n        this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */ (extent));\n      }\n\n      const imageTransform = this.getImageTransform();\n      // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n      const alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity;\n\n      // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n      const dx = imageTransform[4];\n      const dy = imageTransform[5];\n      const dw = image.width * imageTransform[0];\n      const dh = image.height * imageTransform[3];\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height,\n          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n      context.globalAlpha = alpha;\n\n      if (clipped) {\n        context.restore();\n      }\n    }\n\n    this.postCompose(context, frameState, layerState);\n  }\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n  getImage() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @return {!import(\"../../transform.js\").Transform} Image transform.\n   */\n  getImageTransform() {\n    return abstract();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n\n    const imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  }\n}\n\n\nexport default IntermediateCanvasRenderer;\n"]},"metadata":{},"sourceType":"module"}