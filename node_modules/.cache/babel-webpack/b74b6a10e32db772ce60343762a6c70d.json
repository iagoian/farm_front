{"ast":null,"code":"import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n  var resultSelector;\n  var initialState;\n  if (arguments.length == 1) {\n    var options = initialStateOrOptions;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions;\n    resultSelector = identity;\n    scheduler = resultSelectorOrObservable;\n  } else {\n    initialState = initialStateOrOptions;\n    resultSelector = resultSelectorOrObservable;\n  }\n  return new Observable(function (subscriber) {\n    var state = initialState;\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        subscriber: subscriber,\n        iterate: iterate,\n        condition: condition,\n        resultSelector: resultSelector,\n        state: state\n      });\n    }\n    do {\n      if (condition) {\n        var conditionResult = void 0;\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n      var value = void 0;\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n        break;\n      }\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n    return undefined;\n  });\n}\nfunction dispatch(state) {\n  var subscriber = state.subscriber,\n    condition = state.condition;\n  if (subscriber.closed) {\n    return undefined;\n  }\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n  if (condition) {\n    var conditionResult;\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n  var value;\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n  if (subscriber.closed) {\n    return undefined;\n  }\n  subscriber.next(value);\n  if (subscriber.closed) {\n    return undefined;\n  }\n  return this.schedule(state);\n}","map":{"version":3,"sources":["../../../src/internal/observable/generate.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    let resultSelector;\n    let initialState;\n    if (arguments.length == 1) {\n        const options = initialStateOrOptions;\n        initialState = options.initialState;\n        condition = options.condition;\n        iterate = options.iterate;\n        resultSelector = options.resultSelector || identity;\n        scheduler = options.scheduler;\n    }\n    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n        initialState = initialStateOrOptions;\n        resultSelector = identity;\n        scheduler = resultSelectorOrObservable;\n    }\n    else {\n        initialState = initialStateOrOptions;\n        resultSelector = resultSelectorOrObservable;\n    }\n    return new Observable(subscriber => {\n        let state = initialState;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                subscriber,\n                iterate,\n                condition,\n                resultSelector,\n                state\n            });\n        }\n        do {\n            if (condition) {\n                let conditionResult;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return undefined;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            let value;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n        } while (true);\n        return undefined;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, condition } = state;\n    if (subscriber.closed) {\n        return undefined;\n    }\n    if (state.needIterate) {\n        try {\n            state.state = state.iterate(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n    }\n    else {\n        state.needIterate = true;\n    }\n    if (condition) {\n        let conditionResult;\n        try {\n            conditionResult = condition(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!conditionResult) {\n            subscriber.complete();\n            return undefined;\n        }\n        if (subscriber.closed) {\n            return undefined;\n        }\n    }\n    let value;\n    try {\n        value = state.resultSelector(state.state);\n    }\n    catch (err) {\n        subscriber.error(err);\n        return undefined;\n    }\n    if (subscriber.closed) {\n        return undefined;\n    }\n    subscriber.next(value);\n    if (subscriber.closed) {\n        return undefined;\n    }\n    return this.schedule(state);\n}\n//# sourceMappingURL=generate.js.map"]},"metadata":{},"sourceType":"module"}