{"ast":null,"code":"import { Observable } from '../Observable';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\nexport function merge() {\n  var concurrent = Number.POSITIVE_INFINITY;\n  var scheduler = null;\n  for (var _len = arguments.length, observables = new Array(_len), _key = 0; _key < _len; _key++) {\n    observables[_key] = arguments[_key];\n  }\n  var last = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = observables.pop();\n  }\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return observables[0];\n  }\n  return mergeAll(concurrent)(fromArray(observables, scheduler));\n}","map":{"version":3,"sources":["../../../src/internal/observable/merge.ts"],"names":[],"mappings":"AAAA,SAAS,UAAU,QAAQ,eAAe;AAE1C,SAAS,WAAW,QAAQ,qBAAqB;AACjD,SAAS,QAAQ,QAAQ,uBAAuB;AAChD,SAAS,SAAS,QAAQ,aAAa;AAqHvC,OAAM,SAAU,KAAK,GAA2E;EAC/F,IAAI,UAAU,GAAG,MAAM,CAAC,iBAAiB;EACzC,IAAI,SAAS,GAAkB,IAAI;EAAC,kCAFN,WAAiE;IAAjE,WAAiE;EAAA;EAG9F,IAAI,IAAI,GAAQ,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;EACnD,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;IACrB,SAAS,GAAkB,WAAW,CAAC,GAAG,EAAE;IAC5C,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ,EAAE;MACrF,UAAU,GAAW,WAAW,CAAC,GAAG,EAAE;IACvC;GACF,MAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;IACnC,UAAU,GAAW,WAAW,CAAC,GAAG,EAAE;EACvC;EAED,IAAI,SAAS,KAAK,IAAI,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,YAAY,UAAU,EAAE;IAC1F,OAAsB,WAAW,CAAC,CAAC,CAAC;EACrC;EAED,OAAO,QAAQ,CAAI,UAAU,CAAC,CAAC,SAAS,CAAM,WAAW,EAAE,SAAS,CAAC,CAAC;AACxE","sourcesContent":["import { Observable } from '../Observable';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\nexport function merge(...observables) {\n    let concurrent = Number.POSITIVE_INFINITY;\n    let scheduler = null;\n    let last = observables[observables.length - 1];\n    if (isScheduler(last)) {\n        scheduler = observables.pop();\n        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n            concurrent = observables.pop();\n        }\n    }\n    else if (typeof last === 'number') {\n        concurrent = observables.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n        return observables[0];\n    }\n    return mergeAll(concurrent)(fromArray(observables, scheduler));\n}\n//# sourceMappingURL=merge.js.map"]},"metadata":{},"sourceType":"module"}