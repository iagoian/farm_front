{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport { equivalent as equivalentProjection } from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup, { replayDeclutter } from '../../render/canvas/ReplayGroup.js';\nimport { ORDER } from '../../render/replay.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { create as createTransform, compose as composeTransform, reset as resetTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /*@__PURE__*/function (CanvasTileLayerRenderer) {\n  function CanvasVectorTileLayerRenderer(layer) {\n    CanvasTileLayerRenderer.call(this, layer, true);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n    var renderMode = layer.getRenderMode();\n\n    // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  }\n  if (CanvasTileLayerRenderer) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;\n  CanvasVectorTileLayerRenderer.prototype = Object.create(CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype);\n  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\n    if (tile.getState() === TileState.LOADED) {\n      this.createReplayGroup_( /** @type {import(\"../../VectorImageTile.js\").default} */tile, pixelRatio, projection);\n      if (this.context) {\n        this.renderTileImage_( /** @type {import(\"../../VectorImageTile.js\").default} */tile, pixelRatio, projection);\n      }\n    }\n    return tile;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    return (/** @type {import(\"../../VectorImageTile.js\").default} */tile.getImage(tileLayer)\n    );\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var layerRevision = layer.getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return CanvasTileLayerRenderer.prototype.prepareFrame.call(this, frameState, layerState);\n  };\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_(tile, pixelRatio, projection) {\n    var this$1 = this;\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = /** @type {import(\"../../render.js\").OrderFunction} */layer.getRenderOrder() || null;\n    var replayState = tile.getReplayState(layer);\n    if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n    var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var tileExtent = tile.extent;\n    var loop = function loop(t, tt) {\n      var sourceTile = tile.getTile(tile.tileKeys[t]);\n      if (sourceTile.getState() != TileState.LOADED) {\n        return;\n      }\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);\n      var tileProjection = sourceTile.getProjection();\n      var reproject = false;\n      if (!equivalentProjection(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n      replayState.dirty = false;\n      var replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      var render = function render(feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n        if (reproject) {\n          if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent);\n            // tile extent in tile pixel space\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this$1, feature);\n        }\n      }\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    };\n    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      loop(t, tt);\n    }\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n    var features = {};\n    var renderedTiles = /** @type {Array<import(\"../../VectorImageTile.js\").default>} */this.renderedTiles;\n    var bufferedExtent, found;\n    var i, ii;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      var tile = renderedTiles[i];\n      bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n      if (!containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        var sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        var replayGroup = /** @type {CanvasReplayGroup} */sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          var key = getUid(feature);\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      }\n    }\n    return found;\n  };\n\n  /**\n   * @param {import(\"../../VectorTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../transform.js\").Transform} transform Transform.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_(tile, frameState) {\n    var layer = this.getLayer();\n    var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n    var tileGrid = source.getTileGrid();\n    var tileCoord = tile.tileCoord;\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var renderResolution = viewState.resolution / pixelRatio;\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var center = viewState.center;\n    var origin = getTopLeft(tileExtent);\n    var size = frameState.size;\n    var offsetX = Math.round(pixelRatio * size[0] / 2);\n    var offsetY = Math.round(pixelRatio * size[1] / 2);\n    return composeTransform(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);\n  };\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState) {\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var renderMode = layer.getRenderMode();\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      var declutterReplays = layer.getDeclutter() ? {} : null;\n      var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n      var replayTypes = VECTOR_REPLAYS[renderMode];\n      var pixelRatio = frameState.pixelRatio;\n      var rotation = frameState.viewState.rotation;\n      var size = frameState.size;\n      var offsetX, offsetY;\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        rotateAtOffset(context, -rotation, offsetX, offsetY);\n      }\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      var tiles = this.renderedTiles;\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var clips = [];\n      var zs = [];\n      for (var i = tiles.length - 1; i >= 0; --i) {\n        var tile = /** @type {import(\"../../VectorImageTile.js\").default} */tiles[i];\n        if (tile.getState() == TileState.ABORT) {\n          continue;\n        }\n        var tileCoord = tile.tileCoord;\n        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        var transform = undefined;\n        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          var sourceTile = tile.getTile(tile.tileKeys[t]);\n          if (sourceTile.getState() != TileState.LOADED) {\n            continue;\n          }\n          var replayGroup = /** @type {CanvasReplayGroup} */sourceTile.getReplayGroup(layer, tileCoord.toString());\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n          var currentZ = sourceTile.tileCoord[0];\n          var currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity;\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n            if (currentZ < zs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n      if (declutterReplays) {\n        replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n      }\n      if (rotation) {\n        rotateAtOffset(context, rotation, /** @type {number} */offsetX, /** @type {number} */offsetY);\n      }\n    }\n    CanvasTileLayerRenderer.prototype.postCompose.call(this, context, frameState, layerState);\n  };\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);\n    }\n    return loading;\n  };\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_(tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var replays = IMAGE_REPLAYS[layer.getRenderMode()];\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      var tileCoord = tile.wrappedTileCoord;\n      var z = tileCoord[0];\n      var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n      var tileGrid = source.getTileGridForProjection(projection);\n      var resolution = tileGrid.getResolution(z);\n      var context = tile.getContext(layer);\n      var size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        var sourceTile = tile.getTile(tile.tileKeys[i]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        var pixelScale = pixelRatio / resolution;\n        var transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        var replayGroup = /** @type {CanvasReplayGroup} */sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  };\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\nCanvasVectorTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer( /** @type {import(\"../../layer/VectorTile.js\").default} */layer);\n};\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/VectorTileLayer.js"],"names":["const","super","let","t","tt","this"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {listen, unlisten} from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport {buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects} from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport {equivalent as equivalentProjection} from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\nimport CanvasReplayGroup, {replayDeclutter} from '../../render/canvas/ReplayGroup.js';\nimport {ORDER} from '../../render/replay.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport {getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\nimport {\n  create as createTransform,\n  compose as composeTransform,\n  reset as resetTransform,\n  scale as scaleTransform,\n  translate as translateTransform\n} from '../../transform.js';\n\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE,\n    ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nconst VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n\n    super(layer, true);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    const renderMode = layer.getRenderMode();\n\n    // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    super.disposeInternal();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tile = super.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() === TileState.LOADED) {\n      this.createReplayGroup_(/** @type {import(\"../../VectorImageTile.js\").default} */ (tile), pixelRatio, projection);\n      if (this.context) {\n        this.renderTileImage_(/** @type {import(\"../../VectorImageTile.js\").default} */ (tile), pixelRatio, projection);\n      }\n    }\n    return tile;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    return /** @type {import(\"../../VectorImageTile.js\").default} */ (tile).getImage(tileLayer);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const layerRevision = layer.getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return super.prepareFrame(frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  createReplayGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const revision = layer.getRevision();\n    const renderOrder = /** @type {import(\"../../render.js\").OrderFunction} */ (layer.getRenderOrder()) || null;\n\n    const replayState = tile.getReplayState(layer);\n    if (!replayState.dirty && replayState.renderedRevision == revision &&\n        replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const tileExtent = tile.extent;\n\n    for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      const sourceTile = tile.getTile(tile.tileKeys[t]);\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null :\n        buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);\n      const tileProjection = sourceTile.getProjection();\n      let reproject = false;\n      if (!equivalentProjection(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n      replayState.dirty = false;\n      const replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution,\n        pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());\n      const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function(feature) {\n        let styles;\n        const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (reproject) {\n          if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent);\n            // tile extent in tile pixel space\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this, feature);\n        }\n      }\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    }\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n    const features = {};\n\n    const renderedTiles = /** @type {Array<import(\"../../VectorImageTile.js\").default>} */ (this.renderedTiles);\n\n    let bufferedExtent, found;\n    let i, ii;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n      if (!containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n      for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        const sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,\n          tile.tileCoord.toString()));\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n          /**\n           * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n           * @return {?} Callback result.\n           */\n          function(feature) {\n            const key = getUid(feature);\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          }, null);\n      }\n    }\n    return found;\n  }\n\n  /**\n   * @param {import(\"../../VectorTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../transform.js\").Transform} transform Transform.\n   * @private\n   */\n  getReplayTransform_(tile, frameState) {\n    const layer = this.getLayer();\n    const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n    const tileGrid = source.getTileGrid();\n    const tileCoord = tile.tileCoord;\n    const tileResolution = tileGrid.getResolution(tileCoord[0]);\n    const viewState = frameState.viewState;\n    const pixelRatio = frameState.pixelRatio;\n    const renderResolution = viewState.resolution / pixelRatio;\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const center = viewState.center;\n    const origin = getTopLeft(tileExtent);\n    const size = frameState.size;\n    const offsetX = Math.round(pixelRatio * size[0] / 2);\n    const offsetY = Math.round(pixelRatio * size[1] / 2);\n    return composeTransform(this.tmpTransform_,\n      offsetX, offsetY,\n      tileResolution / renderResolution, tileResolution / renderResolution,\n      viewState.rotation,\n      (origin[0] - center[0]) / tileResolution,\n      (center[1] - origin[1]) / tileResolution);\n  }\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  handleFontsChanged_(event) {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  postCompose(context, frameState, layerState) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const renderMode = layer.getRenderMode();\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      const declutterReplays = layer.getDeclutter() ? {} : null;\n      const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n      const replayTypes = VECTOR_REPLAYS[renderMode];\n      const pixelRatio = frameState.pixelRatio;\n      const rotation = frameState.viewState.rotation;\n      const size = frameState.size;\n      let offsetX, offsetY;\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        rotateAtOffset(context, -rotation, offsetX, offsetY);\n      }\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n      const viewHints = frameState.viewHints;\n      const snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      const tiles = this.renderedTiles;\n      const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      const clips = [];\n      const zs = [];\n      for (let i = tiles.length - 1; i >= 0; --i) {\n        const tile = /** @type {import(\"../../VectorImageTile.js\").default} */ (tiles[i]);\n        if (tile.getState() == TileState.ABORT) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n        const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        let transform = undefined;\n        for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          const sourceTile = tile.getTile(tile.tileKeys[t]);\n          if (sourceTile.getState() != TileState.LOADED) {\n            continue;\n          }\n          const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer, tileCoord.toString()));\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n          const currentZ = sourceTile.tileCoord[0];\n          const currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity;\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (let j = 0, jj = clips.length; j < jj; ++j) {\n            const clip = clips[j];\n            if (currentZ < zs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n      if (declutterReplays) {\n        replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n      }\n      if (rotation) {\n        rotateAtOffset(context, rotation,\n          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));\n      }\n    }\n    super.postCompose(context, frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(\n          replayGroup, feature, styles[i], squaredTolerance,\n          this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        replayGroup, feature, styles, squaredTolerance,\n        this.handleStyleImageChange_, this);\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  renderTileImage_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const replays = IMAGE_REPLAYS[layer.getRenderMode()];\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      const tileCoord = tile.wrappedTileCoord;\n      const z = tileCoord[0];\n      const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n      const tileGrid = source.getTileGridForProjection(projection);\n      const resolution = tileGrid.getResolution(z);\n      const context = tile.getContext(layer);\n      const size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      for (let i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        const sourceTile = tile.getTile(tile.tileKeys[i]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        const pixelScale = pixelRatio / resolution;\n        const transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,\n          tile.tileCoord.toString()));\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\nCanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer(/** @type {import(\"../../layer/VectorTile.js\").default} */ (layer));\n};\n\n\nexport default CanvasVectorTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}