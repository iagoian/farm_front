{"ast":null,"code":"/**\n * @module ol/render/canvas/ReplayGroup\n */\n\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { transform2D } from '../../geom/flat/transform.js';\nimport { isEmpty } from '../../obj.js';\nimport ReplayGroup from '../ReplayGroup.js';\nimport ReplayType from '../ReplayType.js';\nimport CanvasReplay from './Replay.js';\nimport CanvasImageReplay from './ImageReplay.js';\nimport CanvasLineStringReplay from './LineStringReplay.js';\nimport CanvasPolygonReplay from './PolygonReplay.js';\nimport CanvasTextReplay from './TextReplay.js';\nimport { ORDER } from '../replay.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\nvar BATCH_CONSTRUCTORS = {\n  'Circle': CanvasPolygonReplay,\n  'Default': CanvasReplay,\n  'Image': CanvasImageReplay,\n  'LineString': CanvasLineStringReplay,\n  'Polygon': CanvasPolygonReplay,\n  'Text': CanvasTextReplay\n};\nvar CanvasReplayGroup = /*@__PURE__*/function (ReplayGroup) {\n  function CanvasReplayGroup(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\n    ReplayGroup.call(this);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = declutterTree;\n\n    /**\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     * @private\n     */\n    this.declutterGroup_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tolerance_ = tolerance;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n    this.replaysByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n  }\n  if (ReplayGroup) CanvasReplayGroup.__proto__ = ReplayGroup;\n  CanvasReplayGroup.prototype = Object.create(ReplayGroup && ReplayGroup.prototype);\n  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n    var declutter = null;\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */\n        declutter[4]++;\n      } else {\n        declutter = this.declutterGroup_ = createEmpty();\n        declutter.push(1);\n      }\n    }\n    return declutter;\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  CanvasReplayGroup.prototype.clip = function clip(context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n  CanvasReplayGroup.prototype.hasReplays = function hasReplays(replays) {\n    for (var zIndex in this.replaysByZIndex_) {\n      var candidates = this.replaysByZIndex_[zIndex];\n      for (var i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  CanvasReplayGroup.prototype.finish = function finish() {\n    for (var zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n      for (var replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var mask = getCircleArray(hitTolerance);\n    var declutteredFeatures;\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function (entry) {\n        return entry.value;\n      });\n    }\n    var replayType;\n\n    /**\n     * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i = 0; i < contextSize; i++) {\n        for (var j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              var result = void 0;\n              if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i, j, replays, replay, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        replayType = ORDER[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            var declutter = declutterReplays[zIndexKey];\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords(transform) {\n    var maxExtent = this.maxExtent_;\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    var replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    var replay = replays[replayType];\n    if (replay === undefined) {\n      var Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  };\n\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n  CanvasReplayGroup.prototype.getReplays = function getReplays() {\n    return this.replaysByZIndex_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1() {\n    return isEmpty(this.replaysByZIndex_);\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  CanvasReplayGroup.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel, opt_replayTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    context.save();\n    this.clip(context, transform);\n    var replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        var replayType = replayTypes[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n    context.restore();\n  };\n  return CanvasReplayGroup;\n}(ReplayGroup);\n\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nvar circleArrayCache = {\n  0: [[true]]\n};\n\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n  var x = radius;\n  var y = 0;\n  var error = 0;\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\nexport function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  var skippedFeatureUids = {};\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var replayData = declutterReplays[zs[z].toString()];\n    for (var i = 0, ii = replayData.length; i < ii;) {\n      var replay = replayData[i++];\n      var transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\nexport default CanvasReplayGroup;","map":{"version":3,"sources":["../../../../src/ol/render/canvas/ReplayGroup.js"],"names":["const","super","let"],"mappings":"AAAA;;;;AAIA,SAAQ,yBAAyB,QAAO,gBAAgB;AACxD,SAAQ,qBAAqB,QAAO,cAAc;AAClD,SAAQ,MAAM,EAAE,WAAW,EAAE,gBAAgB,QAAO,iBAAiB;AACrE,SAAQ,WAAW,QAAO,8BAA8B;AACxD,SAAQ,OAAO,QAAO,cAAc;AACpC,OAAO,WAAW,MAAM,mBAAmB;AAC3C,OAAO,UAAU,MAAM,kBAAkB;AACzC,OAAO,YAAY,MAAM,aAAa;AACtC,OAAO,iBAAiB,MAAM,kBAAkB;AAChD,OAAO,sBAAsB,MAAM,uBAAuB;AAC1D,OAAO,mBAAmB,MAAM,oBAAoB;AACpD,OAAO,gBAAgB,MAAM,iBAAiB;AAC9C,SAAQ,KAAK,QAAO,cAAc;AAClC,SAAQ,MAAM,IAAI,eAAe,EAAE,OAAO,IAAI,gBAAgB,QAAO,oBAAoB;;;;;AAMzFA,IAAM,kBAAkB,GAAG;EACzB,QAAQ,EAAE,mBAAmB;EAC7B,SAAS,EAAE,YAAY;EACvB,OAAO,EAAE,iBAAiB;EAC1B,YAAY,EAAE,sBAAsB;EACpC,SAAS,EAAE,mBAAmB;EAC9B,MAAM,EAAE;CACT;AAGD,IAAM,iBAAiB,GAAoB,aAAA,UAAA,WAAA,EAAA;EAUzC,SAAA,iBAAW,CACT,SAAS,EACT,SAAS,EACT,UAAU,EACV,UAAU,EACV,QAAQ,EACR,aAAa,EACb,gBAAgB,EAChB;IACAC,WAAAA,CAAAA,IAAK,CAAA,IAAC,CAAC;;;;;;IAMP,IAAI,CAAC,cAAc,GAAG,aAAa;;;;;;IAMnC,IAAI,CAAC,eAAe,GAAG,IAAI;;;;;;IAM3B,IAAI,CAAC,UAAU,GAAG,SAAS;;;;;;IAM3B,IAAI,CAAC,UAAU,GAAG,SAAS;;;;;;IAM3B,IAAI,CAAC,SAAS,GAAG,QAAQ;;;;;;IAMzB,IAAI,CAAC,WAAW,GAAG,UAAU;;;;;;IAM7B,IAAI,CAAC,WAAW,GAAG,UAAU;;;;;;IAM7B,IAAI,CAAC,aAAa,GAAG,gBAAgB;;;;;;IAMrC,IAAI,CAAC,gBAAgB,GAAG,CAAA,CAAE;;;;;;IAM1B,IAAI,CAAC,oBAAoB,GAAG,qBAAqB,CAAC,CAAC,EAAE,CAAC,CAAC;;;;;;IAMvD,IAAI,CAAC,sBAAsB,GAAG,eAAe,EAAE;;;;6DAChD;;;;;8BAKD,YAAA,GAAA,SAAA,YAAA,CAAa,KAAK,EAAE;IAClBC,IAAI,SAAS,GAAG,IAAI;IACpB,IAAI,IAAI,CAAC,cAAc,EAAE;MACvB,IAAI,KAAK,EAAE;QACT,SAAS,GAAG,IAAI,CAAC,eAAe;QACV;QAAC,SAAS,CAAC,CAAC,CAAC,EAAG;OACvC,MAAM;QACL,SAAS,GAAG,IAAI,CAAC,eAAe,GAAG,WAAW,EAAE;QAChD,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;MAClB;IACF;IACD,OAAO,SAAS;GACjB;;;;;;8BAMD,IAAA,GAAA,SAAA,IAAA,CAAK,OAAO,EAAE,SAAS,EAAE;IACvBF,IAAM,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACpD,OAAO,CAAC,SAAS,EAAE;IACnB,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;IACpD,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;IACpD,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;IACpD,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;IACpD,OAAO,CAAC,IAAI,EAAE;GACf;;;;;;8BAMD,UAAA,GAAA,SAAA,UAAA,CAAW,OAAO,EAAE;IAClB,KAAKA,IAAM,MAAM,IAAI,IAAI,CAAC,gBAAgB,EAAE;MAC1CA,IAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC;MAChD,KAAKE,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;QAChD,IAAI,OAAO,CAAC,CAAC,CAAC,IAAI,UAAU,EAAE;UAC5B,OAAO,IAAI;QACZ;MACF;IACF;IACD,OAAO,KAAK;GACb;;;;;8BAKD,MAAA,GAAA,SAAA,MAAA,GAAS;IACP,KAAKF,IAAM,IAAI,IAAI,IAAI,CAAC,gBAAgB,EAAE;MACxCA,IAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC;MAC3C,KAAKA,IAAM,SAAS,IAAI,OAAO,EAAE;QAC/B,OAAO,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE;MAC5B;IACF;GACF;;;;;;;;;;;;;8BAaD,0BAAA,GAAA,SAAA,0BAAA,CACE,UAAU,EACV,UAAU,EACV,QAAQ,EACR,YAAY,EACZ,mBAAmB,EACnB,QAAQ,EACR,gBAAgB,EAChB;IAEA,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC;IACvCA,IAAM,WAAW,GAAG,YAAY,GAAG,CAAC,GAAG,CAAC;IACxCA,IAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC,sBAAsB,EAC5D,YAAY,GAAG,GAAG,EAAE,YAAY,GAAG,GAAG,EACtC,CAAC,GAAG,UAAU,EAAE,CAAC,CAAC,GAAG,UAAU,EAC/B,CAAC,QAAQ,EACT,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IACjCA,IAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB;IAEzC,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,KAAK,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,WAAW,EAAE;MACjF,OAAO,CAAC,MAAM,CAAC,KAAK,GAAG,WAAW;MAClC,OAAO,CAAC,MAAM,CAAC,MAAM,GAAG,WAAW;KACpC,MAAM;MACL,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,WAAW,CAAC;IAClD;;;;;IAKDE,IAAI,SAAS;IACb,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,EAAE;MACpC,SAAS,GAAG,WAAW,EAAE;MACzB,gBAAgB,CAAC,SAAS,EAAE,UAAU,CAAC;MACvC,MAAM,CAAC,SAAS,EAAE,UAAU,IAAI,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC,EAAE,SAAS,CAAC;IAC/E;IAEDF,IAAM,IAAI,GAAG,cAAc,CAAC,YAAY,CAAC;IACzCE,IAAI,mBAAmB;IACvB,IAAI,IAAI,CAAC,cAAc,EAAE;MACvB,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,UAAS,KAAK,EAAE;QAClE,OAAO,KAAK,CAAC,KAAK;OACnB,CAAC;IACH;IAEDA,IAAI,UAAU;;;;;;IAMd,SAAS,eAAe,CAAC,OAAO,EAAE;MAChCF,IAAM,SAAS,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,IAAI;MAC3E,KAAKE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;QACpC,KAAKA,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;UACpC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YACd,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,WAAW,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;cAChDA,IAAI,MAAA,GAAA,KAAA,CAAM;cACV,IAAI,EAAE,mBAAmB,KAAK,UAAU,IAAI,UAAU,CAAC,KAAK,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,IAC3F,mBAAmB,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC/C,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC;cAC3B;cACD,IAAI,MAAM,EAAE;gBACV,OAAO,MAAM;eACd,MAAM;gBACL,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,WAAW,CAAC;gBACjD,OAAO,SAAS;cACjB;YACF;UACF;QACF;MACF;IACF;;;IAGDF,IAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;IACzD,EAAE,CAAC,IAAI,CAAC,yBAAyB,CAAC;IAElCE,IAAI,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM;IACjC,KAAK,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;MACnCF,IAAM,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;MAClC,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC;MAC1C,KAAK,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;QACtC,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC;QACrB,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC;QAC5B,IAAI,MAAM,KAAK,SAAS,EAAE;UACxB,IAAI,gBAAgB,KACf,UAAU,IAAI,UAAU,CAAC,KAAK,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YACrEA,IAAM,SAAS,GAAG,gBAAgB,CAAC,SAAS,CAAC;YAC7C,IAAI,CAAC,SAAS,EAAE;cACd,gBAAgB,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aAC3D,MAAM;cACL,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3C;WACF,MAAM;YACL,MAAM,GAAG,MAAM,CAAC,kBAAkB,CAAC,OAAO,EAAE,SAAS,EAAE,QAAQ,EAC7D,mBAAmB,EAAE,eAAe,EAAE,SAAS,CAAC;YAClD,IAAI,MAAM,EAAE;cACV,OAAO,MAAM;YACd;UACF;QACF;MACF;IACF;IACD,OAAO,SAAS;GACjB;;;;;;8BAMD,aAAA,GAAA,SAAA,aAAA,CAAc,SAAS,EAAE;IACvBA,IAAM,SAAS,GAAG,IAAI,CAAC,UAAU;IACjCA,IAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC;IACzBA,IAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC;IACzBA,IAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC;IACzBA,IAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC;IACzBA,IAAM,cAAc,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACvE,WAAW,CACT,cAAc,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE,cAAc,CAAC;IACrD,OAAO,cAAc;GACtB;;;;;8BAKD,SAAA,GAAA,SAAA,SAAA,CAAU,MAAM,EAAE,UAAU,EAAE;IAC5BA,IAAM,SAAS,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG,GAAG;IAChEE,IAAI,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC;IAC9C,IAAI,OAAO,KAAK,SAAS,EAAE;MACzB,OAAO,GAAG,CAAA,CAAE;MACZ,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,GAAG,OAAO;IAC3C;IACDA,IAAI,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC;IAChC,IAAI,MAAM,KAAK,SAAS,EAAE;MACxBF,IAAM,WAAW,GAAG,kBAAkB,CAAC,UAAU,CAAC;MAClD,MAAM,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EACvD,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,CAAC;MAC1E,OAAO,CAAC,UAAU,CAAC,GAAG,MAAM;IAC7B;IACD,OAAO,MAAM;GACd;;;;;8BAKD,UAAA,GAAA,SAAA,UAAA,GAAa;IACX,OAAO,IAAI,CAAC,gBAAgB;GAC7B;;;;;8BAKD,OAAA,GAAA,SAAA,SAAA,GAAU;IACR,OAAO,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC;GACtC;;;;;;;;;;;;8BAYD,MAAA,GAAA,SAAA,MAAA,CACE,OAAO,EACP,SAAS,EACT,YAAY,EACZ,mBAAmB,EACnB,WAAW,EACX,eAAe,EACf,oBAAoB,EACpB;;IAGAA,IAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;IACzD,EAAE,CAAC,IAAI,CAAC,yBAAyB,CAAC;;;;IAIlC,OAAO,CAAC,IAAI,EAAE;IACd,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC;IAE7BA,IAAM,WAAW,GAAG,eAAe,GAAG,eAAe,GAAG,KAAK;IAC7DE,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM;IACjC,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;MACvCF,IAAM,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;MAClC,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC;MAC1C,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;QAChDA,IAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC;QACjC,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC;QAC5B,IAAI,MAAM,KAAK,SAAS,EAAE;UACxB,IAAI,oBAAoB,KACnB,UAAU,IAAI,UAAU,CAAC,KAAK,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YACrEA,IAAM,SAAS,GAAG,oBAAoB,CAAC,SAAS,CAAC;YACjD,IAAI,CAAC,SAAS,EAAE;cACd,oBAAoB,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aAC/D,MAAM;cACL,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3C;WACF,MAAM;YACL,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,mBAAmB,EAAE,WAAW,CAAC;UAClF;QACF;MACF;IACF;IAED,OAAO,CAAC,OAAO,EAAE;GAClB;;EAhX6B,WAAA,CAAA;;;;;;;AAyXhCA,IAAM,gBAAgB,GAAG;EACvB,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC;CACX;;;;;;;;;AAUD,SAAS,0BAA0B,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE;EAC/CE,IAAI,CAAC;EACLF,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;EAC3C,IAAI,CAAC,IAAI,MAAM,EAAE;IACf,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;MAC3B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;IACnB;GACF,MAAM,IAAI,CAAC,GAAG,MAAM,EAAE;IACrB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;MAC/B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;IACnB;EACF;AACF;;;;;;;;;;AAWD,OAAO,SAAS,cAAc,CAAC,MAAM,EAAE;EACrC,IAAI,gBAAgB,CAAC,MAAM,CAAC,KAAK,SAAS,EAAE;IAC1C,OAAO,gBAAgB,CAAC,MAAM,CAAC;EAChC;EAEDA,IAAM,SAAS,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC;EAChCA,IAAM,GAAG,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC;EAChC,KAAKE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;IAClC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC;EAC9B;EAEDA,IAAI,CAAC,GAAG,MAAM;EACdA,IAAI,CAAC,GAAG,CAAC;EACTA,IAAI,KAAK,GAAG,CAAC;EAEb,OAAO,CAAC,IAAI,CAAC,EAAE;IACb,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IACvD,0BAA0B,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC;IAEvD,CAAC,EAAE;IACH,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IAClB,IAAI,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;MAC3B,CAAC,IAAI,CAAC;MACN,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACnB;EACF;EAED,gBAAgB,CAAC,MAAM,CAAC,GAAG,GAAG;EAC9B,OAAO,GAAG;AACX;;;;;;;;AASD,OAAO,SAAS,eAAe,CAAC,gBAAgB,EAAE,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE;EAChFF,IAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,yBAAyB,CAAC;EACpFA,IAAM,kBAAkB,GAAG,CAAA,CAAE;EAC7B,KAAKE,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC3CF,IAAM,UAAU,GAAG,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;IACrD,KAAKE,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG;MAC/CF,IAAM,MAAM,GAAG,UAAU,CAAC,CAAC,EAAE,CAAC;MAC9BA,IAAM,SAAS,GAAG,UAAU,CAAC,CAAC,EAAE,CAAC;MACjC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,kBAAkB,EAAE,WAAW,CAAC;IAC7E;EACF;AACF;AAGD,eAAe,iBAAiB","sourcesContent":["/**\n * @module ol/render/canvas/ReplayGroup\n */\n\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {isEmpty} from '../../obj.js';\nimport ReplayGroup from '../ReplayGroup.js';\nimport ReplayType from '../ReplayType.js';\nimport CanvasReplay from './Replay.js';\nimport CanvasImageReplay from './ImageReplay.js';\nimport CanvasLineStringReplay from './LineStringReplay.js';\nimport CanvasPolygonReplay from './PolygonReplay.js';\nimport CanvasTextReplay from './TextReplay.js';\nimport {ORDER} from '../replay.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\nconst BATCH_CONSTRUCTORS = {\n  'Circle': CanvasPolygonReplay,\n  'Default': CanvasReplay,\n  'Image': CanvasImageReplay,\n  'LineString': CanvasLineStringReplay,\n  'Polygon': CanvasPolygonReplay,\n  'Text': CanvasTextReplay\n};\n\n\nclass CanvasReplayGroup extends ReplayGroup {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay group can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree for declutter processing in postrender.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  constructor(\n    tolerance,\n    maxExtent,\n    resolution,\n    pixelRatio,\n    overlaps,\n    declutterTree,\n    opt_renderBuffer\n  ) {\n    super();\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = declutterTree;\n\n    /**\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     * @private\n     */\n    this.declutterGroup_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tolerance_ = tolerance;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n    this.replaysByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  addDeclutter(group) {\n    let declutter = null;\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */ (declutter[4])++;\n      } else {\n        declutter = this.declutterGroup_ = createEmpty();\n        declutter.push(1);\n      }\n    }\n    return declutter;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n  hasReplays(replays) {\n    for (const zIndex in this.replaysByZIndex_) {\n      const candidates = this.replaysByZIndex_[zIndex];\n      for (let i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  finish() {\n    for (const zKey in this.replaysByZIndex_) {\n      const replays = this.replaysByZIndex_[zKey];\n      for (const replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    resolution,\n    rotation,\n    hitTolerance,\n    skippedFeaturesHash,\n    callback,\n    declutterReplays\n  ) {\n\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(this.hitDetectionTransform_,\n      hitTolerance + 0.5, hitTolerance + 0.5,\n      1 / resolution, -1 / resolution,\n      -rotation,\n      -coordinate[0], -coordinate[1]);\n    const context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    const mask = getCircleArray(hitTolerance);\n    let declutteredFeatures;\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function(entry) {\n        return entry.value;\n      });\n    }\n\n    let replayType;\n\n    /**\n     * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      const imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (let i = 0; i < contextSize; i++) {\n        for (let j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              let result;\n              if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) ||\n                  declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let i, j, replays, replay, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        replayType = ORDER[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (declutterReplays &&\n              (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            const declutter = declutterReplays[zIndexKey];\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation,\n              skippedFeaturesHash, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(\n      flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getReplay(zIndex, replayType) {\n    const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    let replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    let replay = replays[replayType];\n    if (replay === undefined) {\n      const Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_,\n        this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  }\n\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n  getReplays() {\n    return this.replaysByZIndex_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isEmpty() {\n    return isEmpty(this.replaysByZIndex_);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  replay(\n    context,\n    transform,\n    viewRotation,\n    skippedFeaturesHash,\n    snapToPixel,\n    opt_replayTypes,\n    opt_declutterReplays\n  ) {\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    context.save();\n    this.clip(context, transform);\n\n    const replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n    let i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        const replayType = replayTypes[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays &&\n              (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            const declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n\n    context.restore();\n  }\n}\n\n\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nconst circleArrayCache = {\n  0: [[true]]\n};\n\n\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  let i;\n  const radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n\n\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n\n  const arraySize = radius * 2 + 1;\n  const arr = new Array(arraySize);\n  for (let i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n\n  let x = radius;\n  let y = 0;\n  let error = 0;\n\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n\n\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\nexport function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  const zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  const skippedFeatureUids = {};\n  for (let z = 0, zz = zs.length; z < zz; ++z) {\n    const replayData = declutterReplays[zs[z].toString()];\n    for (let i = 0, ii = replayData.length; i < ii;) {\n      const replay = replayData[i++];\n      const transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\n\n\nexport default CanvasReplayGroup;\n"]},"metadata":{},"sourceType":"module"}