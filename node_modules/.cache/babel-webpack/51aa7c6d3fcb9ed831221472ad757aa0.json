{"ast":null,"code":"/**\n * @module ol/style/RegularShape\n */\n\nimport { asString } from '../color.js';\nimport { asColorLike } from '../colorlike.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { CANVAS_LINE_DASH } from '../has.js';\nimport ImageState from '../ImageState.js';\nimport { defaultStrokeStyle, defaultFillStyle, defaultLineCap, defaultLineWidth, defaultLineJoin, defaultMiterLimit } from '../render/canvas.js';\nimport ImageStyle from './Image.js';\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] Outer radius of a star.\n * @property {number} [radius2] Inner radius of a star.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {import(\"./AtlasManager.js\").default} [atlasManager] The atlas manager to use for this symbol. When\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n * symbol is added to an atlas. By default no atlas manager is used.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle]\n * @property {number} strokeWidth\n * @property {number} size\n * @property {string} lineCap\n * @property {Array<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} miterLimit\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\nvar RegularShape = /*@__PURE__*/function (ImageStyle) {\n  function RegularShape(options) {\n    /**\n     * @type {boolean}\n     */\n    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n    ImageStyle.call(this, {\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: 1\n    });\n\n    /**\n     * @private\n     * @type {Array<string|number>}\n     */\n    this.checksums_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius_ = /** @type {number} */options.radius !== undefined ? options.radius : options.radius1;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.hitDetectionImageSize_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./AtlasManager.js\").default|undefined}\n     */\n    this.atlasManager_ = options.atlasManager;\n    this.render_(this.atlasManager_);\n  }\n  if (ImageStyle) RegularShape.__proto__ = ImageStyle;\n  RegularShape.prototype = Object.create(ImageStyle && ImageStyle.prototype);\n  RegularShape.prototype.constructor = RegularShape;\n\n  /**\n   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n  RegularShape.prototype.clone = function clone() {\n    var style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getAnchor = function getAnchor() {\n    return this.anchor_;\n  };\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  RegularShape.prototype.getAngle = function getAngle() {\n    return this.angle_;\n  };\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import(\"./Fill.js\").default} Fill style.\n   * @api\n   */\n  RegularShape.prototype.getFill = function getFill() {\n    return this.fill_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n    return this.hitDetectionCanvas_;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getImage = function getImage(pixelRatio) {\n    return this.canvas_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getImageSize = function getImageSize() {\n    return this.imageSize_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n    return this.hitDetectionImageSize_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getImageState = function getImageState() {\n    return ImageState.LOADED;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getOrigin = function getOrigin() {\n    return this.origin_;\n  };\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  RegularShape.prototype.getPoints = function getPoints() {\n    return this.points_;\n  };\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  RegularShape.prototype.getRadius = function getRadius() {\n    return this.radius_;\n  };\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  RegularShape.prototype.getRadius2 = function getRadius2() {\n    return this.radius2_;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getSize = function getSize() {\n    return this.size_;\n  };\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import(\"./Stroke.js\").default} Stroke style.\n   * @api\n   */\n  RegularShape.prototype.getStroke = function getStroke() {\n    return this.stroke_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n    return undefined;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.load = function load() {};\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {};\n\n  /**\n   * @protected\n   * @param {import(\"./AtlasManager.js\").default|undefined} atlasManager An atlas manager.\n   */\n  RegularShape.prototype.render_ = function render_(atlasManager) {\n    var imageSize;\n    var lineCap = '';\n    var lineJoin = '';\n    var miterLimit = 0;\n    var lineDash = null;\n    var lineDashOffset = 0;\n    var strokeStyle;\n    var strokeWidth = 0;\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = defaultStrokeStyle;\n      }\n      strokeStyle = asColorLike(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === undefined) {\n        strokeWidth = defaultLineWidth;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      if (!CANVAS_LINE_DASH) {\n        lineDash = null;\n        lineDashOffset = 0;\n      }\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === undefined) {\n        lineJoin = defaultLineJoin;\n      }\n      lineCap = this.stroke_.getLineCap();\n      if (lineCap === undefined) {\n        lineCap = defaultLineCap;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === undefined) {\n        miterLimit = defaultMiterLimit;\n      }\n    }\n    var size = 2 * (this.radius_ + strokeWidth) + 1;\n\n    /** @type {RenderOptions} */\n    var renderOptions = {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n    if (atlasManager === undefined) {\n      // no atlas manager is used, create a new canvas\n      var context = createCanvasContext2D(size, size);\n      this.canvas_ = context.canvas;\n\n      // canvas.width and height are rounded to the closest integer\n      size = this.canvas_.width;\n      imageSize = size;\n      this.draw_(renderOptions, context, 0, 0);\n      this.createHitDetectionCanvas_(renderOptions);\n    } else {\n      // an atlas manager is used, add the symbol to an atlas\n      size = Math.round(size);\n      var hasCustomHitDetectionImage = !this.fill_;\n      var renderHitDetectionCallback;\n      if (hasCustomHitDetectionImage) {\n        // render the hit-detection image into a separate atlas image\n        renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);\n      }\n      var id = this.getChecksum();\n      var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);\n      this.canvas_ = info.image;\n      this.origin_ = [info.offsetX, info.offsetY];\n      imageSize = info.image.width;\n      if (hasCustomHitDetectionImage) {\n        this.hitDetectionCanvas_ = info.hitImage;\n        this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];\n      } else {\n        this.hitDetectionCanvas_ = this.canvas_;\n        this.hitDetectionImageSize_ = [imageSize, imageSize];\n      }\n    }\n    this.anchor_ = [size / 2, size / 2];\n    this.size_ = [size, size];\n    this.imageSize_ = [imageSize, imageSize];\n  };\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  RegularShape.prototype.draw_ = function draw_(renderOptions, context, x, y) {\n    var i, angle0, radiusC;\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n    context.beginPath();\n    var points = this.points_;\n    if (points === Infinity) {\n      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n    if (this.fill_) {\n      var color = this.fill_.getColor();\n      if (color === null) {\n        color = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = /** @type {CanvasLineCap} */renderOptions.lineCap;\n      context.lineJoin = /** @type {CanvasLineJoin} */renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n    context.closePath();\n  };\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   */\n  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_(renderOptions) {\n    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n    if (this.fill_) {\n      this.hitDetectionCanvas_ = this.canvas_;\n      return;\n    }\n\n    // if no fill style is set, create an extra hit-detection image with a\n    // default fill style\n    var context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n    this.hitDetectionCanvas_ = context.canvas;\n    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n  };\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_(renderOptions, context, x, y) {\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n    context.beginPath();\n    var points = this.points_;\n    if (points === Infinity) {\n      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      var i, radiusC, angle0;\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n    context.fillStyle = asString(defaultFillStyle);\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.stroke();\n    }\n    context.closePath();\n  };\n\n  /**\n   * @return {string} The checksum.\n   */\n  RegularShape.prototype.getChecksum = function getChecksum() {\n    var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';\n    var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';\n    var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];\n    if (recalculate) {\n      var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');\n      this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];\n    }\n    return (/** @type {string} */this.checksums_[0]\n    );\n  };\n  return RegularShape;\n}(ImageStyle);\nexport default RegularShape;","map":{"version":3,"sources":["../../../src/ol/style/RegularShape.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/style/RegularShape\n */\n\nimport {asString} from '../color.js';\nimport {asColorLike} from '../colorlike.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {CANVAS_LINE_DASH} from '../has.js';\nimport ImageState from '../ImageState.js';\nimport {defaultStrokeStyle, defaultFillStyle, defaultLineCap, defaultLineWidth, defaultLineJoin, defaultMiterLimit} from '../render/canvas.js';\nimport ImageStyle from './Image.js';\n\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] Outer radius of a star.\n * @property {number} [radius2] Inner radius of a star.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {import(\"./AtlasManager.js\").default} [atlasManager] The atlas manager to use for this symbol. When\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n * symbol is added to an atlas. By default no atlas manager is used.\n */\n\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle]\n * @property {number} strokeWidth\n * @property {number} size\n * @property {string} lineCap\n * @property {Array<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} miterLimit\n */\n\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\nclass RegularShape extends ImageStyle {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    /**\n     * @type {boolean}\n     */\n    const rotateWithView = options.rotateWithView !== undefined ?\n      options.rotateWithView : false;\n\n    super({\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: 1\n    });\n\n    /**\n     * @private\n     * @type {Array<string|number>}\n     */\n    this.checksums_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius_ = /** @type {number} */ (options.radius !== undefined ?\n      options.radius : options.radius1);\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.hitDetectionImageSize_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./AtlasManager.js\").default|undefined}\n     */\n    this.atlasManager_ = options.atlasManager;\n\n    this.render_(this.atlasManager_);\n\n  }\n\n  /**\n   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n  clone() {\n    const style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getAnchor() {\n    return this.anchor_;\n  }\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  getAngle() {\n    return this.angle_;\n  }\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import(\"./Fill.js\").default} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getHitDetectionImage(pixelRatio) {\n    return this.hitDetectionCanvas_;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getImage(pixelRatio) {\n    return this.canvas_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageSize() {\n    return this.imageSize_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getHitDetectionImageSize() {\n    return this.hitDetectionImageSize_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageState() {\n    return ImageState.LOADED;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getOrigin() {\n    return this.origin_;\n  }\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  getPoints() {\n    return this.points_;\n  }\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return this.radius_;\n  }\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  getRadius2() {\n    return this.radius2_;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import(\"./Stroke.js\").default} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listenImageChange(listener, thisArg) {\n    return undefined;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  load() {}\n\n  /**\n   * @inheritDoc\n   */\n  unlistenImageChange(listener, thisArg) {}\n\n  /**\n   * @protected\n   * @param {import(\"./AtlasManager.js\").default|undefined} atlasManager An atlas manager.\n   */\n  render_(atlasManager) {\n    let imageSize;\n    let lineCap = '';\n    let lineJoin = '';\n    let miterLimit = 0;\n    let lineDash = null;\n    let lineDashOffset = 0;\n    let strokeStyle;\n    let strokeWidth = 0;\n\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = defaultStrokeStyle;\n      }\n      strokeStyle = asColorLike(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === undefined) {\n        strokeWidth = defaultLineWidth;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      if (!CANVAS_LINE_DASH) {\n        lineDash = null;\n        lineDashOffset = 0;\n      }\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === undefined) {\n        lineJoin = defaultLineJoin;\n      }\n      lineCap = this.stroke_.getLineCap();\n      if (lineCap === undefined) {\n        lineCap = defaultLineCap;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === undefined) {\n        miterLimit = defaultMiterLimit;\n      }\n    }\n\n    let size = 2 * (this.radius_ + strokeWidth) + 1;\n\n    /** @type {RenderOptions} */\n    const renderOptions = {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n\n    if (atlasManager === undefined) {\n      // no atlas manager is used, create a new canvas\n      const context = createCanvasContext2D(size, size);\n      this.canvas_ = context.canvas;\n\n      // canvas.width and height are rounded to the closest integer\n      size = this.canvas_.width;\n      imageSize = size;\n\n      this.draw_(renderOptions, context, 0, 0);\n\n      this.createHitDetectionCanvas_(renderOptions);\n    } else {\n      // an atlas manager is used, add the symbol to an atlas\n      size = Math.round(size);\n\n      const hasCustomHitDetectionImage = !this.fill_;\n      let renderHitDetectionCallback;\n      if (hasCustomHitDetectionImage) {\n        // render the hit-detection image into a separate atlas image\n        renderHitDetectionCallback =\n            this.drawHitDetectionCanvas_.bind(this, renderOptions);\n      }\n\n      const id = this.getChecksum();\n      const info = atlasManager.add(\n        id, size, size, this.draw_.bind(this, renderOptions),\n        renderHitDetectionCallback);\n\n      this.canvas_ = info.image;\n      this.origin_ = [info.offsetX, info.offsetY];\n      imageSize = info.image.width;\n\n      if (hasCustomHitDetectionImage) {\n        this.hitDetectionCanvas_ = info.hitImage;\n        this.hitDetectionImageSize_ =\n            [info.hitImage.width, info.hitImage.height];\n      } else {\n        this.hitDetectionCanvas_ = this.canvas_;\n        this.hitDetectionImageSize_ = [imageSize, imageSize];\n      }\n    }\n\n    this.anchor_ = [size / 2, size / 2];\n    this.size_ = [size, size];\n    this.imageSize_ = [imageSize, imageSize];\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  draw_(renderOptions, context, x, y) {\n    let i, angle0, radiusC;\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n\n    context.beginPath();\n\n    let points = this.points_;\n    if (points === Infinity) {\n      context.arc(\n        renderOptions.size / 2, renderOptions.size / 2,\n        this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      const radius2 = (this.radius2_ !== undefined) ? this.radius2_\n        : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n          renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n\n\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n      if (color === null) {\n        color = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = /** @type {CanvasLineCap} */ (renderOptions.lineCap);\n      context.lineJoin = /** @type {CanvasLineJoin} */ (renderOptions.lineJoin);\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n    context.closePath();\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   */\n  createHitDetectionCanvas_(renderOptions) {\n    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n    if (this.fill_) {\n      this.hitDetectionCanvas_ = this.canvas_;\n      return;\n    }\n\n    // if no fill style is set, create an extra hit-detection image with a\n    // default fill style\n    const context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n    this.hitDetectionCanvas_ = context.canvas;\n\n    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  drawHitDetectionCanvas_(renderOptions, context, x, y) {\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n\n    context.beginPath();\n\n    let points = this.points_;\n    if (points === Infinity) {\n      context.arc(\n        renderOptions.size / 2, renderOptions.size / 2,\n        this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      const radius2 = (this.radius2_ !== undefined) ? this.radius2_\n        : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      let i, radiusC, angle0;\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n          renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n\n    context.fillStyle = asString(defaultFillStyle);\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.stroke();\n    }\n    context.closePath();\n  }\n\n  /**\n   * @return {string} The checksum.\n   */\n  getChecksum() {\n    const strokeChecksum = this.stroke_ ?\n      this.stroke_.getChecksum() : '-';\n    const fillChecksum = this.fill_ ?\n      this.fill_.getChecksum() : '-';\n\n    const recalculate = !this.checksums_ ||\n        (strokeChecksum != this.checksums_[1] ||\n        fillChecksum != this.checksums_[2] ||\n        this.radius_ != this.checksums_[3] ||\n        this.radius2_ != this.checksums_[4] ||\n        this.angle_ != this.checksums_[5] ||\n        this.points_ != this.checksums_[6]);\n\n    if (recalculate) {\n      const checksum = 'r' + strokeChecksum + fillChecksum +\n          (this.radius_ !== undefined ? this.radius_.toString() : '-') +\n          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +\n          (this.angle_ !== undefined ? this.angle_.toString() : '-') +\n          (this.points_ !== undefined ? this.points_.toString() : '-');\n      this.checksums_ = [checksum, strokeChecksum, fillChecksum,\n        this.radius_, this.radius2_, this.angle_, this.points_];\n    }\n\n    return /** @type {string} */ (this.checksums_[0]);\n  }\n}\n\n\nexport default RegularShape;\n"]},"metadata":{},"sourceType":"module"}