{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, createEmpty, equals, getIntersection, isEmpty } from '../../extent.js';\nimport IntermediateCanvasRenderer from './IntermediateCanvas.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nvar CanvasTileLayerRenderer = /*@__PURE__*/function (IntermediateCanvasRenderer) {\n  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n    IntermediateCanvasRenderer.call(this, tileLayer);\n\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = opt_noContext ? null : createCanvasContext2D();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.imageTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n  }\n  if (IntermediateCanvasRenderer) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;\n  CanvasTileLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype);\n  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n\n  /**\n   * @private\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_(tile) {\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  CanvasTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileSource = /** @type {import(\"../../source/Tile.js\").default} */tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileSource = /** @type {import(\"../../source/Tile.js\").default} */tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n        if (this.isDrawableTile_(tile)) {\n          var uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (this.newTiles_ || !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n      var context = this.context;\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_) || this.renderedRevision != sourceRevision) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function (a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n    var scale = this.renderedResolution / viewResolution;\n    var transform = composeTransform(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    return this.renderedTiles.length > 0;\n  };\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileSource = /** @type {import(\"../../source/Tile.js\").default} */tileLayer.getSource();\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.getImage = function getImage() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n    return this.imageTransform_;\n  };\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    return (/** @type {import(\"../../ImageTile.js\").default} */tile.getImage()\n    );\n  };\n  return CanvasTileLayerRenderer;\n}(IntermediateCanvasRenderer);\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.TILE;\n};\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\nCanvasTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasTileLayerRenderer( /** @type {import(\"../../layer/Tile.js\").default} */layer);\n};\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/TileLayer.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, createEmpty, equals, getIntersection, isEmpty} from '../../extent.js';\nimport IntermediateCanvasRenderer from './IntermediateCanvas.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nclass CanvasTileLayerRenderer extends IntermediateCanvasRenderer {\n\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   * @param {boolean=} opt_noContext Skip the context creation.\n   */\n  constructor(tileLayer, opt_noContext) {\n\n    super(tileLayer);\n\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = opt_noContext ? null : createCanvasContext2D();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.imageTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED ||\n        tileState == TileState.EMPTY ||\n        tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n\n    const pixelRatio = frameState.pixelRatio;\n    const size = frameState.size;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    let oversampling = Math.round(viewResolution / tileResolution) || 1;\n    let extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    const imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource, projection, tilesToDrawByZ);\n\n    const hints = frameState.viewHints;\n    const animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    let tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n        if (this.isDrawableTile_(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            const inTransition = tile.inTransition(uid);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord, tmpTileRange, tmpExtent);\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n\n      }\n    }\n\n    const renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\n      this.newTiles_ ||\n          !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) ||\n          this.renderedRevision != sourceRevision ||\n          oversampling != this.oversampling_ ||\n          !animatingOrInteracting && renderedResolution != this.renderedResolution\n    )) {\n\n      const context = this.context;\n      if (context) {\n        const tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        const width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        const height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        const canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if ((this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) ||\n              this.renderedRevision != sourceRevision) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      const zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function(a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      let currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      let tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (const tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    const scale = this.renderedResolution / viewResolution;\n    const transform = composeTransform(this.imageTransform_,\n      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n      scale, scale,\n      0,\n      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\n      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform,\n      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n      pixelRatio / viewResolution, -pixelRatio / viewResolution,\n      0,\n      -viewCenter[0], -viewCenter[1]);\n\n\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\n      projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n\n    return this.renderedTiles.length > 0;\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter,\n      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageTransform() {\n    return this.imageTransform_;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return /** @type {import(\"../../ImageTile.js\").default} */ (tile).getImage();\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\nCanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasTileLayerRenderer(/** @type {import(\"../../layer/Tile.js\").default} */ (layer));\n};\n\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\n\nexport default CanvasTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}