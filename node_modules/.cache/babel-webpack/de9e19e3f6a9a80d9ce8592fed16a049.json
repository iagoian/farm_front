{"ast":null,"code":"/**\n * @module ol/proj/transforms\n */\nimport { isEmpty } from '../obj.js';\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nvar transforms = {};\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  var transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  var transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}","map":{"version":3,"sources":["../../../src/ol/proj/transforms.js"],"names":["let","const"],"mappings":"AAAA;;;AAGA,SAAQ,OAAO,QAAO,WAAW;;;;;;AAOjCA,IAAI,UAAU,GAAG,CAAA,CAAE;;;;;AAMnB,OAAO,SAAS,KAAK,GAAG;EACtB,UAAU,GAAG,CAAA,CAAE;AAChB;;;;;;;;;;AAWD,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,WAAW,EAAE;EACpDC,IAAM,UAAU,GAAG,MAAM,CAAC,OAAO,EAAE;EACnCA,IAAM,eAAe,GAAG,WAAW,CAAC,OAAO,EAAE;EAC7C,IAAI,EAAE,UAAU,IAAI,UAAU,CAAC,EAAE;IAC/B,UAAU,CAAC,UAAU,CAAC,GAAG,CAAA,CAAE;EAC5B;EACD,UAAU,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC,GAAG,WAAW;AACtD;;;;;;;;;;;AAYD,OAAO,SAAS,MAAM,CAAC,MAAM,EAAE,WAAW,EAAE;EAC1CA,IAAM,UAAU,GAAG,MAAM,CAAC,OAAO,EAAE;EACnCA,IAAM,eAAe,GAAG,WAAW,CAAC,OAAO,EAAE;EAC7CA,IAAM,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC;EACzD,OAAO,UAAU,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC;EAC9C,IAAI,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,EAAE;IACnC,OAAO,UAAU,CAAC,UAAU,CAAC;EAC9B;EACD,OAAO,SAAS;AACjB;;;;;;;;AASD,OAAO,SAAS,GAAG,CAAC,UAAU,EAAE,eAAe,EAAE;EAC/CD,IAAI,SAAS;EACb,IAAI,UAAU,IAAI,UAAU,IAAI,eAAe,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;IACzE,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC;EACpD;EACD,OAAO,SAAS;AACjB","sourcesContent":["/**\n * @module ol/proj/transforms\n */\nimport {isEmpty} from '../obj.js';\n\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nlet transforms = {};\n\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  const transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  let transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}\n"]},"metadata":{},"sourceType":"module"}