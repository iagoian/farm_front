{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\nvar TileCache = /*@__PURE__*/function (LRUCache) {\n  function TileCache(opt_highWaterMark) {\n    LRUCache.call(this, opt_highWaterMark);\n  }\n  if (LRUCache) TileCache.__proto__ = LRUCache;\n  TileCache.prototype = Object.create(LRUCache && LRUCache.prototype);\n  TileCache.prototype.constructor = TileCache;\n\n  /**\n   * @param {!Object<string, import(\"./TileRange.js\").default>} usedTiles Used tiles.\n   */\n  TileCache.prototype.expireCache = function expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      var tile = this.peekLast();\n      var zKey = tile.tileCoord[0].toString();\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  };\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    var key = this.peekFirstKey();\n    var tileCoord = fromKey(key);\n    var z = tileCoord[0];\n    this.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n  return TileCache;\n}(LRUCache);\nexport default TileCache;","map":{"version":3,"sources":["../../src/ol/TileCache.js"],"names":["super","const"],"mappings":"AAAA;;;AAGA,OAAO,QAAQ,MAAM,uBAAuB;AAC5C,SAAQ,OAAO,EAAE,MAAM,QAAO,gBAAgB;AAE9C,IAAM,SAAS,GAAiB,aAAA,UAAA,QAAA,EAAA;EAK9B,SAAA,SAAW,CAAC,iBAAiB,EAAE;IAE7BA,QAAAA,CAAAA,IAAK,CAAA,IAAA,EAAC,iBAAiB,CAAC;;;;6CAEzB;;;;;sBAKD,WAAA,GAAA,SAAA,WAAA,CAAY,SAAS,EAAE;IACrB,OAAO,IAAI,CAAC,cAAc,EAAE,EAAE;MAC5BC,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE;MAC5BA,IAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;MACzC,IAAI,IAAI,IAAI,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;QACjE;OACD,MAAM;QACL,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,EAAE;MACrB;IACF;GACF;;;;;sBAKD,kBAAA,GAAA,SAAA,kBAAA,GAAqB;IACnB,IAAI,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;MACzB;IACD;IACDA,IAAM,GAAG,GAAG,IAAI,CAAC,YAAY,EAAE;IAC/BA,IAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC;IAC9BA,IAAM,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;IACtB,IAAI,CAAC,OAAO,CAAC,UAAS,IAAI,EAAE;MAC1B,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QAC3B,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACnC,IAAI,CAAC,OAAO,EAAE;MACf;KACF,EAAE,IAAI,CAAC;GACT;;EA1CqB,QAAA,CAAA;AA8CxB,eAAe,SAAS","sourcesContent":["/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n\n  /**\n   * @param {number=} opt_highWaterMark High water mark.\n   */\n  constructor(opt_highWaterMark) {\n\n    super(opt_highWaterMark);\n\n  }\n\n  /**\n   * @param {!Object<string, import(\"./TileRange.js\").default>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      const zKey = tile.tileCoord[0].toString();\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(function(tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  }\n}\n\n\nexport default TileCache;\n"]},"metadata":{},"sourceType":"module"}