{"ast":null,"code":"/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport { asString } from '../../color.js';\nimport { snap } from '../../geom/flat/simplify.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport CanvasInstruction, { fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction } from './Instruction.js';\nimport CanvasReplay from './Replay.js';\nvar CanvasPolygonReplay = /*@__PURE__*/function (CanvasReplay) {\n  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n  if (CanvasReplay) CanvasPolygonReplay.__proto__ = CanvasReplay;\n  CanvasPolygonReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle != undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.drawCircle = function drawCircle(circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(circleGeometry, feature);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(multiPolygonGeometry, feature);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.finish = function finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    var tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n  };\n\n  /**\n   * @private\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   */\n  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_(geometry) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n  return CanvasPolygonReplay;\n}(CanvasReplay);\nexport default CanvasPolygonReplay;","map":{"version":3,"sources":["../../../../src/ol/render/canvas/PolygonReplay.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport {asString} from '../../color.js';\nimport {snap} from '../../geom/flat/simplify.js';\nimport {defaultFillStyle} from '../canvas.js';\nimport CanvasInstruction, {\n  fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction\n} from './Instruction.js';\nimport CanvasReplay from './Replay.js';\n\n\nclass CanvasPolygonReplay extends CanvasReplay {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    super(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle != undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawCircle(circleGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(\n      flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(circleGeometry, feature);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawPolygon(polygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawMultiPolygon(multiPolygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(multiPolygonGeometry, feature);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    const tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   */\n  setFillStrokeStyles_(geometry) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n}\n\n\nexport default CanvasPolygonReplay;\n"]},"metadata":{},"sourceType":"module"}