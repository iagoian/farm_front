{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport { getUid } from '../util.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport { distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment } from '../coordinate.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { TRUE, FALSE } from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport { getValues } from '../obj.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if ( /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature\n    );\n  } else if ( /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element) {\n    return (/** @type {import(\"../Feature.js\").default} */ /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element\n    );\n  }\n}\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\nvar Snap = /*@__PURE__*/function (PointerInteraction) {\n  function Snap(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    PointerInteraction.call(this, pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * @type {function(SegmentData, SegmentData): number}\n     * @private\n     */\n    this.sortByDistance_ = sortByDistance.bind(this);\n\n    /**\n    * Segment RTree for each layer\n    * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n    * @private\n    */\n    this.rBush_ = new RBush();\n\n    /**\n    * @const\n    * @private\n    * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n  if (PointerInteraction) Snap.__proto__ = PointerInteraction;\n  Snap.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  Snap.prototype.constructor = Snap;\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.addFeature = function addFeature(feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  };\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  Snap.prototype.getFeatures_ = function getFeatures_() {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.handleEvent = function handleEvent(evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return PointerInteraction.prototype.handleEvent.call(this, evt);\n  };\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_(evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_(evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_(evt) {\n    var feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.handleUpEvent = function handleUpEvent(evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.removeFeature = function removeFeature(feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.setMap = function setMap(map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = /** @type {Array<import(\"../Feature.js\").default>} */this.getFeatures_();\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    PointerInteraction.prototype.setMap.call(this, map);\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  Snap.prototype.snapTo = function snapTo(pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n    var snappedToVertex = false;\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      var closestSegment = segments[0].segment;\n      var isCircle = segments[0].feature.getGeometry().getType() === GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate, /** @type {import(\"../geom/Circle.js\").default} */segments[0].feature.getGeometry());\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return (/** @type {Result} */{\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      }\n    );\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  Snap.prototype.updateFeature_ = function updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_(feature, geometry) {\n    var polygon = fromCircle(geometry);\n    var coordinates = polygon.getCoordinates()[0];\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = /** @type {SegmentData} */{\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_(feature, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = /** @type {SegmentData} */{\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_(feature, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = /** @type {SegmentData} */{\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_(feature, geometry) {\n    var points = geometry.getCoordinates();\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData = /** @type {SegmentData} */{\n        feature: feature,\n        segment: [coordinates, coordinates]\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_(feature, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData = /** @type {SegmentData} */{\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePointGeometry_ = function writePointGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = /** @type {SegmentData} */{\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_(feature, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = /** @type {SegmentData} */{\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  return Snap;\n}(PointerInteraction);\n\n/**\n * Sort segments by distance, helper function\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {Snap}\n */\nfunction sortByDistance(a, b) {\n  var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\nexport default Snap;","map":{"version":3,"sources":["../../../src/ol/interaction/Snap.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport {getUid} from '../util.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport {distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment} from '../coordinate.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {TRUE, FALSE} from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport {getValues} from '../obj.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature;\n  } else if (/** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element) {\n    return /** @type {import(\"../Feature.js\").default} */ (/** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element);\n  }\n\n}\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n\n    /**\n     * @type {function(SegmentData, SegmentData): number}\n     * @private\n     */\n    this.sortByDistance_ = sortByDistance.bind(this);\n\n\n    /**\n    * Segment RTree for each layer\n    * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n    * @private\n    */\n    this.rBush_ = new RBush();\n\n\n    /**\n    * @const\n    * @private\n    * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, opt_listen) {\n    const register = opt_listen !== undefined ? opt_listen : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_, this);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, opt_unlisten) {\n    const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function(node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(this.features_, CollectionEventType.ADD,\n            this.handleFeatureAdd_, this),\n          listen(this.features_, CollectionEventType.REMOVE,\n            this.handleFeatureRemove_, this)\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(this.source_, VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_, this),\n          listen(this.source_, VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_, this)\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n\n    const lowerLeft = map.getCoordinateFromPixel(\n      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    const upperRight = map.getCoordinateFromPixel(\n      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    let segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function(segment) {\n        return segment.feature.getGeometry().getType() !==\n            GeometryType.CIRCLE;\n      });\n    }\n\n    let snappedToVertex = false;\n    let snapped = false;\n    let vertex = null;\n    let vertexPixel = null;\n    let dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      const closestSegment = segments[0].segment;\n      const isCircle = segments[0].feature.getGeometry().getType() ===\n          GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (segments[0].feature.getGeometry()));\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return (\n      /** @type {Result} */ ({\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      })\n    );\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const polygon = fromCircle(geometry);\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = /** @type {SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: [coordinates, coordinates]\n      });\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n          const segmentData = /** @type {SegmentData} */ ({\n            feature: feature,\n            segment: segment\n          });\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    const segmentData = /** @type {SegmentData} */ ({\n      feature: feature,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = /** @type {SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n}\n\n\n/**\n * Sort segments by distance, helper function\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {Snap}\n */\nfunction sortByDistance(a, b) {\n  const deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  const deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap;\n"]},"metadata":{},"sourceType":"module"}