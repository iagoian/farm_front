{"ast":null,"code":"import _assertThisInitialized from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/dev-faculdade/Portifolio/Teste-Job-V2/Farm/farm_front/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n  var bufferCreationInterval = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\nvar BufferTimeOperator = /*#__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _classCallCheck(this, BufferTimeOperator);\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n  _createClass(BufferTimeOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n  }]);\n  return BufferTimeOperator;\n}();\nvar Context = /*#__PURE__*/_createClass(function Context() {\n  _classCallCheck(this, Context);\n  this.buffer = [];\n});\nvar BufferTimeSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(BufferTimeSubscriber, _Subscriber);\n  var _super = _createSuper(BufferTimeSubscriber);\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this;\n    _classCallCheck(this, BufferTimeSubscriber);\n    _this = _super.call(this, destination);\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n    var context = _this.openContext();\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _assertThisInitialized(_this),\n        scheduler: scheduler\n      };\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n    return _this;\n  }\n  _createClass(BufferTimeSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var contexts = this.contexts;\n      var len = contexts.length;\n      var filledBufferContext;\n      for (var i = 0; i < len; i++) {\n        var context = contexts[i];\n        var buffer = context.buffer;\n        buffer.push(value);\n        if (buffer.length == this.maxBufferSize) {\n          filledBufferContext = context;\n        }\n      }\n      if (filledBufferContext) {\n        this.onBufferFull(filledBufferContext);\n      }\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      this.contexts.length = 0;\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_error\", this).call(this, err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var contexts = this.contexts,\n        destination = this.destination;\n      while (contexts.length > 0) {\n        var context = contexts.shift();\n        destination.next(context.buffer);\n      }\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_complete\", this).call(this);\n    }\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this.contexts = null;\n    }\n  }, {\n    key: \"onBufferFull\",\n    value: function onBufferFull(context) {\n      this.closeContext(context);\n      var closeAction = context.closeAction;\n      closeAction.unsubscribe();\n      this.remove(closeAction);\n      if (!this.closed && this.timespanOnly) {\n        context = this.openContext();\n        var bufferTimeSpan = this.bufferTimeSpan;\n        var timeSpanOnlyState = {\n          subscriber: this,\n          context: context,\n          bufferTimeSpan: bufferTimeSpan\n        };\n        this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n      }\n    }\n  }, {\n    key: \"openContext\",\n    value: function openContext() {\n      var context = new Context();\n      this.contexts.push(context);\n      return context;\n    }\n  }, {\n    key: \"closeContext\",\n    value: function closeContext(context) {\n      this.destination.next(context.buffer);\n      var contexts = this.contexts;\n      var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n      if (spliceIndex >= 0) {\n        contexts.splice(contexts.indexOf(context), 1);\n      }\n    }\n  }]);\n  return BufferTimeSubscriber;\n}(Subscriber);\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n    bufferTimeSpan = state.bufferTimeSpan,\n    subscriber = state.subscriber,\n    scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n    context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    let length = arguments.length;\n    let scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    let bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    let maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nclass BufferTimeOperator {\n    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n}\nclass Context {\n    constructor() {\n        this.buffer = [];\n    }\n}\nclass BufferTimeSubscriber extends Subscriber {\n    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        super(destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        const context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            const closeState = { subscriber: this, context };\n            const creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        let filledBufferContext;\n        for (let i = 0; i < len; i++) {\n            const context = contexts[i];\n            const buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    }\n    _error(err) {\n        this.contexts.length = 0;\n        super._error(err);\n    }\n    _complete() {\n        const { contexts, destination } = this;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        this.contexts = null;\n    }\n    onBufferFull(context) {\n        this.closeContext(context);\n        const closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            const bufferTimeSpan = this.bufferTimeSpan;\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    }\n    openContext() {\n        const context = new Context();\n        this.contexts.push(context);\n        return context;\n    }\n    closeContext(context) {\n        this.destination.next(context.buffer);\n        const contexts = this.contexts;\n        const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    }\n}\nfunction dispatchBufferTimeSpanOnly(state) {\n    const subscriber = state.subscriber;\n    const prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n    const context = subscriber.openContext();\n    const action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    const { subscriber, context } = arg;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map"]},"metadata":{},"sourceType":"module"}